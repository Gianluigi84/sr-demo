=== added file 'shadow_robot/dataglove/dataglove_processing/CMakeLists.txt'
--- shadow_robot/dataglove/dataglove_processing/CMakeLists.txt	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/CMakeLists.txt	2010-11-12 15:58:27 +0000
@@ -0,0 +1,33 @@
+cmake_minimum_required(VERSION 2.4.6)
+include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)
+
+# Set the build type.  Options are:
+#  Coverage       : w/ debug symbols, w/o optimization, w/ code-coverage
+#  Debug          : w/ debug symbols, w/o optimization
+#  Release        : w/o debug symbols, w/ optimization
+#  RelWithDebInfo : w/ debug symbols, w/ optimization
+#  MinSizeRel     : w/o debug symbols, w/ optimization, stripped binaries
+#set(ROS_BUILD_TYPE RelWithDebInfo)
+
+rosbuild_init()
+
+#set the default path for built executables to the "bin" directory
+set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
+#set the default path for built libraries to the "lib" directory
+set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)
+
+#uncomment if you have defined messages
+#rosbuild_genmsg()
+#uncomment if you have defined services
+#rosbuild_gensrv()
+
+#common commands for building c++ executables and libraries
+#rosbuild_add_library(${PROJECT_NAME} src/example.cpp)
+#target_link_libraries(${PROJECT_NAME} another_library)
+rosbuild_add_boost_directories(ptr_container)
+rosbuild_add_executable(dataglove_processing src/dataglove_processing_node.cpp src/dataglove_processing.cpp src/measure.cpp src/measure.cpp src/particle.cpp src/particle_sr_hand.cpp)
+rosbuild_link_boost(dataglove_processing thread)
+
+#TESTS
+rosbuild_add_gtest(test/test_dataglove_processing test/test_dataglove_processing.cpp src/dataglove_processing.cpp src/measure.cpp src/measure.cpp src/particle.cpp src/particle_sr_hand.cpp)
+rosbuild_link_boost(dataglove_processing thread)

=== removed file 'shadow_robot/dataglove/dataglove_processing/CMakeLists.txt'
--- shadow_robot/dataglove/dataglove_processing/CMakeLists.txt	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/CMakeLists.txt	1970-01-01 00:00:00 +0000
@@ -1,34 +0,0 @@
-cmake_minimum_required(VERSION 2.4.6)
-include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)
-
-# Set the build type.  Options are:
-#  Coverage       : w/ debug symbols, w/o optimization, w/ code-coverage
-#  Debug          : w/ debug symbols, w/o optimization
-#  Release        : w/o debug symbols, w/ optimization
-#  RelWithDebInfo : w/ debug symbols, w/ optimization
-#  MinSizeRel     : w/o debug symbols, w/ optimization, stripped binaries
-#set(ROS_BUILD_TYPE RelWithDebInfo)
-
-rosbuild_init()
-
-#set the default path for built executables to the "bin" directory
-set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
-#set the default path for built libraries to the "lib" directory
-set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)
-
-#uncomment if you have defined messages
-#rosbuild_genmsg()
-#uncomment if you have defined services
-rosbuild_gensrv()
-
-#common commands for building c++ executables and libraries
-#rosbuild_add_library(${PROJECT_NAME} src/example.cpp)
-#target_link_libraries(${PROJECT_NAME} another_library)
-#rosbuild_add_boost_directories()
-#rosbuild_link_boost(${PROJECT_NAME} thread)
-#rosbuild_add_executable(example examples/example.cpp)
-#target_link_libraries(example ${PROJECT_NAME})
-
-#rosbuild_add_executable(optical_dataglove src/optical_dataglove.cpp src/optical_dataglove_node.cpp)
-rosbuild_add_executable(message_publisher src/three_dimensions src/two_dimensions.cpp src/reverse_kinematics.cpp src/database_mapping.cpp src/message_publisher.cpp src/optical_dataglove_node.cpp)
-

=== added file 'shadow_robot/dataglove/dataglove_processing/Makefile'
--- shadow_robot/dataglove/dataglove_processing/Makefile	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/Makefile	2010-11-09 11:11:27 +0000
@@ -0,0 +1,1 @@
+include $(shell rospack find mk)/cmake.mk
\ No newline at end of file

=== removed file 'shadow_robot/dataglove/dataglove_processing/Makefile'
--- shadow_robot/dataglove/dataglove_processing/Makefile	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/Makefile	1970-01-01 00:00:00 +0000
@@ -1,1 +0,0 @@
-include $(shell rospack find mk)/cmake.mk
\ No newline at end of file

=== added directory 'shadow_robot/dataglove/dataglove_processing/bin'
=== added directory 'shadow_robot/dataglove/dataglove_processing/bin/test'

=== removed file 'shadow_robot/dataglove/dataglove_processing/dataglove-UML.png'
Binary files shadow_robot/dataglove/dataglove_processing/dataglove-UML.png	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq and shadow_robot/dataglove/dataglove_processing/dataglove-UML.png	1970-01-01 00:00:00 +0000 differ
=== added directory 'shadow_robot/dataglove/dataglove_processing/include'
=== removed directory 'shadow_robot/dataglove/dataglove_processing/include'
=== added file 'shadow_robot/dataglove/dataglove_processing/include/dataglove_processing.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/dataglove_processing.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/dataglove_processing.hpp	2010-11-16 17:54:37 +0000
@@ -0,0 +1,137 @@
+/**
+ * @file dataglove_processing.hpp
+ * @author Ugo Cupcic <ugo@shadowrobot.com>, Contact <contact@shadowrobot.com>
+ * @date 9 Nov 2010
+ *
+ * @brief 
+ *
+ *
+ */
+
+#ifndef DATAGLOVE_PROCESSING_HPP_
+#define DATAGLOVE_PROCESSING_HPP_
+
+#include <ros/ros.h>
+#include <vector>
+
+#include "gtest/gtest_prod.h"
+#include <boost/ptr_container/ptr_vector.hpp>
+#include <boost/smart_ptr.hpp>
+#include <boost/thread.hpp>
+#include "threadpool/threadpool.hpp"
+
+#include <math_utils.hpp>
+#include "particle_sr_hand.hpp"
+#include "measure.hpp"
+
+
+namespace dataglove
+{
+struct CompareParticleWeights : std::binary_function<ParticleSrHand, ParticleSrHand, bool>
+{
+    CompareParticleWeights()
+    {
+    }
+    bool operator()( const ParticleSrHand& v1, const ParticleSrHand& v2 ) const
+    {
+        return (v1.get_weight() < v2.get_weight());
+    }
+};
+
+class DatagloveProcessing
+{
+    friend class DatagloveProcessingTest;
+    FRIEND_TEST(DatagloveProcessingTest, resampling);
+    FRIEND_TEST(DatagloveProcessingTest, pfInitWeights);
+    FRIEND_TEST(DatagloveProcessingTest, pfInitPos);
+    FRIEND_TEST(DatagloveProcessingTest, sortByWeights);
+    FRIEND_TEST(DatagloveProcessingTest, updateCycle);
+
+public:
+    DatagloveProcessing();
+    ~DatagloveProcessing();
+
+    /**
+     * This update loop will call update_cycle() which does the
+     * actual update.
+     *
+     * @return 0 if ok, 1 if resampled, -1 if error
+     */
+    int update();
+
+    //consts
+    static const unsigned int total_number_of_particles;
+    static const float average_weight;
+    static const float n_min;
+
+private:
+    //ROS stuff
+    ros::NodeHandle nh, nh_tilde;
+    /// the rate at which the update loop of the particle filter is called
+    ros::Rate update_rate;
+
+    //threadpool
+    boost::threadpool::pool threadpool;
+
+    //type
+    typedef boost::ptr_vector<ParticleSrHand>::iterator part_it_t;
+    typedef std::auto_ptr< boost::ptr_vector<ParticleSrHand> > part_auto_ptr_t;
+
+    //variables
+    /// stores the particle cloud
+    boost::shared_ptr< boost::ptr_vector<ParticleSrHand> > particle_cloud;
+    /**
+     *  needed when doing the resampling: temporary stores the
+     *  new particle cloud, which is then retransfered to the
+     *  particle_cloud variable.
+     */
+    boost::shared_ptr< boost::ptr_vector<ParticleSrHand> > particle_cloud_tmp;
+    boost::shared_ptr<math_utils::MathUtils> math_utils;
+    boost::shared_ptr<Measure> last_measure;
+    boost::mutex last_measure_mutex;
+
+    //number of efficient particles (weight is big enough)
+    float n_eff;
+    float n_eff_standard;
+    //comparison structure
+    CompareParticleWeights compare_particle_weights;
+    ///sum_squared_weights needs to be thread safe
+    boost::shared_ptr<float> sum_weights;
+    boost::shared_ptr<float> sum_squared_weights;
+    boost::shared_ptr<boost::mutex> mutex_sum_weights;
+
+    //functions
+
+    /**
+     * Update each particle in a thread, using the threadpool.
+     *
+     * @return 0 if ok, 1 if resampled, -1 if error
+     */
+    int update_cycle();
+
+    /**
+     * The update loop will call each particle
+     * update in a thread, using the threadpool.
+     */
+    void update_particle_in_thread();
+
+    /**
+     * Resample the point cloud using stochastic Universal Sampling(SUS).
+     *
+     * @return 1 if resampling, 0 if no resampling, -1 if error
+     */
+    int resampling();
+    /**
+     * Does a roulette wheel selection for a given fitness.
+     * @param fitness
+     * @return return a pointer to the selected particle
+     */
+    ParticleSrHand* roulette_wheel_selection( float fitness );
+
+    std::vector<float> get_weights_vector();
+    std::vector<std::vector<float> > get_particle_positions_vector();
+}; // end class DatagloveProcessing
+
+} //end namespace
+
+#endif /* DATAGLOVE_PROCESSING_HPP_ */

=== added file 'shadow_robot/dataglove/dataglove_processing/include/measure.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/measure.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/measure.hpp	2010-11-09 12:20:08 +0000
@@ -0,0 +1,23 @@
+/**
+ * @file measure.hpp
+ * @author Ugo Cupcic <ugo@shadowrobot.com>, Contact <contact@shadowrobot.com>
+ * @date 9 Nov 2010
+ *
+ * @brief 
+ *
+ *
+ */
+
+#ifndef MEASURE_HPP_
+#define MEASURE_HPP_
+
+namespace dataglove
+{
+class Measure
+{
+    Measure();
+    ~Measure();
+};
+}
+
+#endif /* MEASURE_HPP_ */

=== removed directory 'shadow_robot/dataglove/dataglove_processing/include/optical_dataglove'
=== removed file 'shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/data_analyser.h'
--- shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/data_analyser.h	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/data_analyser.h	1970-01-01 00:00:00 +0000
@@ -1,41 +0,0 @@
-#ifndef DATA_ANALYSER_H_
-#define DATA_ANALYSER_H_
-
-#include "optical_dataglove/joint_data.h"
-#include <map>
-
-namespace opticaldataglove{
-
-/*
- * Abstract class to define methods to make conversions between the raw source to the fingertips positions
- * Key methods to implement in subclass are getFingerTipPositions and getHandModel, which is used to determine the distances between the human hand articulations
- */
-class DataAnalyser
-{
-
-public:
-/*
- * Constructor
- */
-    DataAnalyser()
-    {
-    };
-/*
- * Destructor
- */
-    ~DataAnalyser()
-    {
-    };
-
-    virtual std::map<std::string, double> getFingerTipPositions()=0;
-    virtual std::map<std::string, double> getHandModel()=0;
-
-protected:
-    
-    std::map<std::string, double> fingerTipPositions;
-    std::map<std::string, double> handModel;
-    
-
-};
-}
-#endif //DATA_ANALYSER_H_

=== removed file 'shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/database_mapping.h'
--- shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/database_mapping.h	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/database_mapping.h	1970-01-01 00:00:00 +0000
@@ -1,41 +0,0 @@
-#ifndef DATABASEMAPPING_H_
-#define DATABASEMAPPING_H_
-
-#include "optical_dataglove/position_mapper.h"
-
-namespace opticaldataglove{
-
-/*
- * Class used to perform the conversion between fingertips positions to joints values using a Database of known positions
- */
-class DatabaseMapping : public PositionMapper
-{
-public :
-
-/*
- * Constructor
- * @param data_analyser : data analyser performing computing to get information from hand
- */
-    DatabaseMapping(boost::shared_ptr<DataAnalyser> data_analyser);
-    
-/*
- * Destructor
- */
-    ~DatabaseMapping();
-
-/*
- * Returns a map with the angles of that the hand should take
- */
-    virtual std::map<std::string, JointData> getHandPositions();
-
-private :
-    
-/*
- * Initializes the hand position
- */
-   virtual void initializeHandPositions(); 
-
-};
-}
-
-#endif //#DATABASEMAPPING_H_

=== removed file 'shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/hand_model.h'
--- shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/hand_model.h	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/hand_model.h	1970-01-01 00:00:00 +0000
@@ -1,52 +0,0 @@
-#ifndef HAND_MODEL_H_
-#define HAND_MODEL_H_
-
-#include <string>
-
-namespace opticaldataglove{
-
-/*
- * Class describing the distances between the joints on the human hand. These should be get only once.
- */
-class HandModel
-{
-
-public :
-
-    double THJ3_to_THJ2;
-    double THJ2_to_THJ1;
-    
-    double FFJ3_to_FFJ2;
-    double FFJ2_to_FFJ1;
-    
-    double MFJ3_to_MFJ2;
-    double MFJ2_to_MFJ1;
-    
-    double RFJ3_to_RFJ2;
-    double RFJ2_to_RFJ1;
-
-    double LFJ3_to_LFJ2;
-    double LFJ2_to_LFJ1;
-    
-    HandModel() :
-        THJ3_to_THJ2(1.0),THJ2_to_THJ1(2.0),FFJ3_to_FFJ2(1.0),FFJ2_to_FFJ1(2.0),
-        MFJ3_to_MFJ2(1.0),MFJ2_to_MFJ1(2.0),RFJ3_to_RFJ2(1.0),RFJ2_to_RFJ1(2.0),
-        LFJ3_to_LFJ2(1.0),LFJ2_to_LFJ1(2.0)
-    {
-    }
-
-    HandModel(HandModel& hm) :
-        THJ3_to_THJ2(hm.THJ3_to_THJ2),THJ2_to_THJ1(hm.THJ2_to_THJ1),FFJ3_to_FFJ2(hm.FFJ3_to_FFJ2),FFJ2_to_FFJ1(hm.FFJ2_to_FFJ1),
-        MFJ3_to_MFJ2(hm.MFJ3_to_MFJ2),MFJ2_to_MFJ1(hm.MFJ2_to_MFJ1),RFJ3_to_RFJ2(hm.RFJ3_to_RFJ2),RFJ2_to_RFJ1(hm.RFJ2_to_RFJ1),
-        LFJ3_to_LFJ2(hm.LFJ3_to_LFJ2),LFJ2_to_LFJ1(hm.LFJ2_to_LFJ1)
-    {
-    };
-
-    HandModel(const HandModel& hm) :
-        THJ3_to_THJ2(hm.THJ3_to_THJ2),THJ2_to_THJ1(hm.THJ2_to_THJ1),FFJ3_to_FFJ2(hm.FFJ3_to_FFJ2),FFJ2_to_FFJ1(hm.FFJ2_to_FFJ1),
-        MFJ3_to_MFJ2(hm.MFJ3_to_MFJ2),MFJ2_to_MFJ1(hm.MFJ2_to_MFJ1),RFJ3_to_RFJ2(hm.RFJ3_to_RFJ2),RFJ2_to_RFJ1(hm.RFJ2_to_RFJ1),
-        LFJ3_to_LFJ2(hm.LFJ3_to_LFJ2),LFJ2_to_LFJ1(hm.LFJ2_to_LFJ1)
-    {
-}
-
-#endif //HAND_MODEL_H_

=== removed file 'shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/joint_data.h'
--- shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/joint_data.h	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/joint_data.h	1970-01-01 00:00:00 +0000
@@ -1,46 +0,0 @@
-#ifndef JOINT_DATA_H_
-#define JOINT_DATA_H_
-
-#include <string>
-
-namespace opticaldataglove{
-
-/*
- * Describes a joint of the hand with any possible information
- */
-class JointData
-{
-
-public:
-  double position;
-  double target;
-  double temperature;
-  double current;
-  double force;
-  std::string flags;
-  int jointIndex;
-  double min;
-  double max;
-  short isJointZero;
-
-  JointData() :
-    position(0.0), target(0.0), temperature(0.0), current(0.0), force(0.0), flags(""), jointIndex(0),
-    min(0.0), max(90.0), isJointZero(0)
-  {
-  }
-
-  JointData(JointData& jd) :
-    position(jd.position), target(jd.target), temperature(jd.temperature), current(jd.current), force(jd.force),
-        flags(jd.flags), jointIndex(jd.jointIndex), min(jd.min), max(jd.max), isJointZero(jd.isJointZero)
-  {
-  }
-
-  JointData(const JointData& jd) :
-    position(jd.position), target(jd.target), temperature(jd.temperature), current(jd.current), force(jd.force),
-        flags(jd.flags), jointIndex(jd.jointIndex), min(jd.min), max(jd.max), isJointZero(jd.isJointZero)
-  {
-  }
-};
-
-}
-#endif //JOINT_DATA_H_

=== removed file 'shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/message_publisher.h'
--- shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/message_publisher.h	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/message_publisher.h	1970-01-01 00:00:00 +0000
@@ -1,56 +0,0 @@
-#ifndef MESSAGE_PUBLISHER_H_
-#define MESSAGE_PUBLISHER_H_
-
-#include <string>
-#include <vector>
-#include <map>
-#include <ros/ros.h>
-#include "opticaldataglove/Start.h"
-#include "opticaldataglove/Stop.h"
-#include "optical_dataglove/joint_data.h"
-#include "optical_dataglove/position_mapper.h"
-#include <boost/smart_ptr.hpp>
-#include <sensor_msgs/JointState.h>
-
-namespace opticaldataglove
-{
-
-/*
- * Interfacing the acquisition and computing process with the hand over ROS
- */
-class MessagePublisher 
-{
-public:
-
-    MessagePublisher(boost::shared_ptr<PositionMapper> position_mapper);
-
-
-    ~MessagePublisher();
-
-    std::string publishedTopic;
-    
-/*
- * Publishes the position of the hand on the specified topic
- */
-    void publish();
-/*
- * ROS service to start the publishing
- */
-    bool start(opticaldataglove::Start::Request &req, opticaldataglove::Start::Response &res);
-/*
- * ROS service to stop the publishing
- */
-    bool stop(opticaldataglove::Stop::Request &req, opticaldataglove::Stop::Response &res);
-
-private:
-    
-   std::map<std::string, JointData> handPositions;
-   ros::NodeHandle node;
-   boost::shared_ptr<PositionMapper> positionMapper;
-   ros::Publisher publisher;
-   ros::ServiceServer service_start;
-   ros::ServiceServer service_stop;
-   bool isPublishing;    
-};
-}
-#endif //MESSAGE_PUBLISHER_H_

=== removed file 'shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/optical_dataglove.h'
--- shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/optical_dataglove.h	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/optical_dataglove.h	1970-01-01 00:00:00 +0000
@@ -1,45 +0,0 @@
-/**
- * @file   optical_dataglove.h
- * @author Ugo Cupcic <ugo@shadowrobot.com>
- * @date   Wed Jul  7 18:08:41 2010
- * 
- * @brief  The Optical Dataglove Class.
- * 
- * 
- */
-
-#ifndef OPTICAL_DATAGLOVE_H_
-#define OPTICAL_DATAGLOVE_H_
-
-#include <ros/ros.h>
-#include <sensor_msgs/Image.h>
-#include <image_transport/image_transport.h>
-#include "cv_bridge/CvBridge.h"
-#include <opencv/cv.h>
-#include <opencv/highgui.h>
-#include <math.h>
-
-namespace optical_dataglove
-{
-  class OpticalDataglove 
-  {
-  public:
-    OpticalDataglove(ros::NodeHandle & nh);
-    ~OpticalDataglove(){};
-
-  protected:
-    ros::NodeHandle nh_;
-    image_transport::ImageTransport it_;
-    image_transport::Subscriber image_sub_;
-    sensor_msgs::CvBridge bridge_;
-    image_transport::Publisher image_pub_;
-    cv::Mat img_in_;
-    cv::Mat img_hsv_;
-    IplImage *cv_input_;
-    IplImage cv_output_;
-
-    void imageCallback (const sensor_msgs::ImageConstPtr & msg_ptr);
-  };
-};
-
-#endif      /* !  OPTICAL_DATAGLOVE_H_  */

=== removed file 'shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/position_mapper.h'
--- shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/position_mapper.h	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/position_mapper.h	1970-01-01 00:00:00 +0000
@@ -1,44 +0,0 @@
-#ifndef POSITION_MAPPER_H_
-#define POSITION_MAPPER_H_
-
-#include "optical_dataglove/joint_data.h"
-#include "optical_dataglove/data_analyser.h"
-#include <boost/smart_ptr.hpp>
-#include <map>
-
-namespace opticaldataglove{
-
-/*
- * Abstract class to interface the DataAnalyser with the Message Publisher : computing the data received by the analyser and convert it to joints positions
- */
-class PositionMapper
-{
-
-public:
-    
-/*
- * Constructor
- */
-    PositionMapper()
-    {
-    };
-
-/*
- * Destructor
- */
-    ~PositionMapper()
-    {
-    };
-
-    virtual std::map<std::string, JointData> getHandPositions()=0;
-
-protected:
-    
-    std::map<std::string, JointData> handPositions;
-    std::map<std::string, double> fingerTipPositions;
-    boost::shared_ptr<DataAnalyser> dataAnalyser;
-    virtual void initializeHandPositions()=0;
-};
-}
-
-#endif //POSITION_MAPPER_H_

=== removed file 'shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/reverse_kinematics.h'
--- shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/reverse_kinematics.h	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/reverse_kinematics.h	1970-01-01 00:00:00 +0000
@@ -1,32 +0,0 @@
-#ifndef REVERSE_KINEMATICS_H_
-#define REVERSE_KINEMATICS_H_
-
-#include "optical_dataglove/position_mapper.h"
-
-namespace opticaldataglove{
-
-/*
- * Class to use reverse kinematics to perform the mapping between fingertips position and joint positions
- */
-class ReverseKinematics : public PositionMapper
-{
-public :
-
-/*
- * Constructor
- * @param data_analyser : DataAnalyser which is getting the fingertips positions
- */
-    ReverseKinematics(boost::shared_ptr<DataAnalyser> data_analyser);
-    
-    ~ReverseKinematics();
-
-    virtual std::map<std::string, JointData> getHandPositions();
-
-private : 
-    
-    virtual void initializeHandPositions();
-
-};
-}
-
-#endif //REVERSE_KINEMATICS_H_

=== removed file 'shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/three_dimensions.h'
--- shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/three_dimensions.h	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/three_dimensions.h	1970-01-01 00:00:00 +0000
@@ -1,32 +0,0 @@
-#ifndef THREE_DIMENSIONS_H_
-#define THREE_DIMENSIONS_H_
-
-#include "optical_dataglove/data_analyser.h"
-
-namespace opticaldataglove{
-
-/*
- * Class performing the conversion between 3D pictures to fingertips positions
- */
-class ThreeDimensionsAnalyser : public DataAnalyser
-{
-public :
-
-/*
- * Constructor
- */
-    ThreeDimensionsAnalyser();
-
-/*
- * Destructor
- */
-    ~ThreeDimensionsAnalyser();
-
-
-    virtual std::map<std::string, double> getFingerTipPositions();
-    virtual std::map<std::string, double> getHandModel();
-
-};
-}
-
-#endif //THREE_DIMENSIONS_H_

=== removed file 'shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/two_dimensions.h'
--- shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/two_dimensions.h	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/include/optical_dataglove/two_dimensions.h	1970-01-01 00:00:00 +0000
@@ -1,32 +0,0 @@
-#ifndef TWO_DIMENSIONS_H_
-#define TWO_DIMENSIONS_H_
-
-#include "optical_dataglove/data_analyser.h"
-
-namespace opticaldataglove{
-
-/*
- * Class performing the conversion between 2D pictures to fingertips positions
- */
-class TwoDimensionsAnalyser : public DataAnalyser
-{
-public :
-
-/*
- * Constructor
- */
-    TwoDimensionsAnalyser();
-
-/*
- * Destructor
- */
-    ~TwoDimensionsAnalyser();
-
-
-    virtual std::map<std::string, double> getFingerTipPositions();
-    virtual std::map<std::string, double> getHandModel();
-
-};
-}
-
-#endif //TWO_DIMENSIONS_H_

=== added file 'shadow_robot/dataglove/dataglove_processing/include/particle.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/particle.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/particle.hpp	2010-11-16 13:59:16 +0000
@@ -0,0 +1,92 @@
+/**
+ * @file particle.hpp
+ * @author Ugo Cupcic <ugo@shadowrobot.com>, Contact <contact@shadowrobot.com>
+ * @date 9 Nov 2010
+ *
+ * @brief Generic particle from which our particles will inherit.
+ *
+ *
+ */
+
+#ifndef PARTICLE_HPP_
+#define PARTICLE_HPP_
+
+#include "measure.hpp"
+#include <boost/ptr_container/ptr_vector.hpp>
+#include <boost/thread.hpp>
+#include <boost/smart_ptr.hpp>
+#include <boost/noncopyable.hpp>
+
+namespace dataglove
+{
+class Particle : boost::noncopyable
+{
+public:
+    Particle();
+    /**
+     * initialises the weight to 1/population_size
+     * @param population_size the size of the cloud
+     */
+    Particle( int population_size );
+    ///copy constructor
+    Particle( boost::ptr_vector<Particle>::iterator particle, bool reset_weight, float average_weight );
+    ~Particle();
+
+    //particle filter functions
+    /**
+     * Initialise the model with random
+     * number.
+     */
+    virtual void init_model() = 0;
+
+    /**
+     * Runs the update cycle: first prediction()
+     * then compute_probability(last_measure)
+     *
+     * @param sum_squared_weights a pointer to the Sum of weights for the whole cloud
+     * @param mutex_sum_squared_weights a pointer to the mutex used to block this variable
+     */
+    virtual void update(float* sum_weights, boost::mutex* mutex_sum_weights) = 0;
+
+
+    //accessors
+    float get_weight() const;
+
+    /**
+     * set the weight / squared weight for the current particle
+     * @param new_weight the new weight to set
+     * @return the squared weight value
+     */
+    float set_weight( float new_weight );
+    void set_last_measure( boost::shared_ptr<Measure> last_measure );
+
+protected:
+    float weight;
+    float squared_weight;
+    int population_size;
+    boost::shared_ptr<Measure> last_measure;
+
+    /**
+     * Initialise the weight of the particle to 1/population_size
+     * @param population_size The size of the population.
+     */
+    void init_weight( int population_size );
+
+    /**
+     * Apply a random force to the particle, thus "predicting" the next position
+     * of the particle. Also called motion model.
+     */
+    virtual void prediction() = 0;
+
+    /**
+     * Update the weight of the particle: compute the probability of
+     * producing this measure given the current object position.
+     *
+     * @param measure A measure.
+     */
+    virtual void compute_probability( ) = 0;
+
+};
+}
+
+#endif /* PARTICLE_HPP_ */

=== added file 'shadow_robot/dataglove/dataglove_processing/include/particle_sr_hand.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/particle_sr_hand.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/particle_sr_hand.hpp	2010-11-16 13:53:38 +0000
@@ -0,0 +1,59 @@
+/**
+ * @file particle_sr_hand.cpp
+ * @author Ugo Cupcic <ugo@shadowrobot.com>, Contact <contact@shadowrobot.com>
+ * @date 9 Nov 2010
+ *
+ * @brief 
+ *
+ *
+ */
+
+#ifndef PARTICLE_SR_HAND_CPP_
+#define PARTICLE_SR_HAND_CPP_
+
+#include "particle.hpp"
+#include "measure.hpp"
+
+#include <gtest/gtest_prod.h>
+
+#include <sr_hand/hand/virtual_shadowhand_library.h>
+#include <math_utils.hpp>
+
+#include <boost/smart_ptr.hpp>
+#include <vector>
+
+using namespace shadowrobot;
+
+namespace dataglove
+{
+class ParticleSrHand : public virtual VirtualShadowhandLibrary, public virtual Particle
+{
+public:
+    ParticleSrHand();
+    ParticleSrHand( int population_size );
+    ParticleSrHand( boost::ptr_vector<ParticleSrHand>::iterator particle, bool reset_weight, float average_weight );
+    ~ParticleSrHand();
+
+    //particle filter functions
+    virtual void init_model();
+
+    /**
+     * Runs the update cycle: first prediction()
+     * then compute_probability(last_measure)
+     *
+     * @param sum_weights a pointer to the Sum of weights for the whole cloud
+     * @param mutex_squared_weights a pointer to the mutex used to block this variable
+     */
+    virtual void update(float* sum_weights, boost::mutex* mutex_sum_weights);
+
+    std::vector<float> get_positions();
+protected:
+    boost::shared_ptr<math_utils::MathUtils> math_utils;
+
+    virtual void prediction();
+    virtual void compute_probability();
+
+};
+}
+
+#endif /* PARTICLE_SR_HAND_CPP_ */

=== added directory 'shadow_robot/dataglove/dataglove_processing/include/threadpool'
=== added directory 'shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool'
=== added file 'shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool.hpp	2007-11-21 23:00:14 +0000
@@ -0,0 +1,28 @@
+/*! \file
+* \brief Main include.
+*
+* This is the only file you have to include in order to use the 
+* complete threadpool library.
+*
+* Copyright (c) 2005-2007 Philipp Henkel
+*
+* Use, modification, and distribution are  subject to the
+* Boost Software License, Version 1.0. (See accompanying  file
+* LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+*
+* http://threadpool.sourceforge.net
+*
+*/
+
+#ifndef THREADPOOL_HPP_INCLUDED
+#define THREADPOOL_HPP_INCLUDED
+
+#include "./threadpool/future.hpp"
+#include "./threadpool/pool.hpp"
+
+#include "./threadpool/pool_adaptors.hpp"
+#include "./threadpool/task_adaptors.hpp"
+
+
+#endif // THREADPOOL_HPP_INCLUDED
+

=== added directory 'shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail'
=== added file 'shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail/future.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail/future.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail/future.hpp	2007-11-21 23:00:50 +0000
@@ -0,0 +1,215 @@
+/*! \file
+* \brief TODO.
+*
+* TODO. 
+*
+* Copyright (c) 2005-2007 Philipp Henkel
+*
+* Use, modification, and distribution are  subject to the
+* Boost Software License, Version 1.0. (See accompanying  file
+* LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+*
+* http://threadpool.sourceforge.net
+*
+*/
+
+
+#ifndef THREADPOOL_DETAIL_FUTURE_IMPL_HPP_INCLUDED
+#define THREADPOOL_DETAIL_FUTURE_IMPL_HPP_INCLUDED
+
+
+#include "locking_ptr.hpp"
+
+#include <boost/smart_ptr.hpp>
+#include <boost/optional.hpp>
+#include <boost/thread/mutex.hpp>
+#include <boost/thread/condition.hpp>
+#include <boost/thread/xtime.hpp>
+#include <boost/utility/result_of.hpp>
+#include <boost/static_assert.hpp>
+#include <boost/type_traits.hpp>
+
+namespace boost { namespace threadpool { namespace detail 
+{
+
+template<class Result> 
+class future_impl
+{
+public:
+  typedef Result const & result_type; //!< Indicates the functor's result type.
+
+  typedef Result future_result_type; //!< Indicates the future's result type.
+  typedef future_impl<future_result_type> future_type;
+
+private:
+    volatile bool m_ready;
+    volatile future_result_type m_result;
+
+    mutable mutex m_monitor;
+    mutable condition m_condition_ready;	
+
+    volatile bool m_is_cancelled;
+    volatile bool m_executing;
+
+public:
+
+
+public:
+
+  future_impl()
+  : m_ready(false)
+  , m_is_cancelled(false)
+  {
+  }
+
+  bool ready() const volatile
+  {
+    return m_ready; 
+  }
+
+  void wait() const volatile
+  {
+    const future_type* self = const_cast<const future_type*>(this);
+    mutex::scoped_lock lock(self->m_monitor);
+
+    while(!m_ready)
+    {
+      self->m_condition_ready.wait(lock);
+    }
+  }
+
+
+  bool timed_wait(boost::xtime const & timestamp) const
+  {
+    const future_type* self = const_cast<const future_type*>(this);
+    mutex::scoped_lock lock(self->m_monitor);
+
+    while(!m_ready)
+    {
+      if(!self->m_condition_ready.timed_wait(lock, timestamp)) return false;
+    }
+
+    return true;
+  }
+
+
+  result_type operator()() const volatile
+  {
+    wait();
+/*
+    if( throw_exception_ != 0 )
+    {
+      throw_exception_( this );
+    }
+*/
+ 
+    return *(const_cast<const future_result_type*>(&m_result));
+  }
+
+
+  void set_value(future_result_type const & r) volatile
+  {
+    locking_ptr<future_type, mutex> lockedThis(*this, m_monitor);
+    if(!m_ready && !m_is_cancelled)
+    {
+      lockedThis->m_result = r;
+      lockedThis->m_ready = true;
+      lockedThis->m_condition_ready.notify_all();
+    }
+  }
+/*
+  template<class E> void set_exception() // throw()
+  {
+    m_impl->template set_exception<E>();
+  }
+
+  template<class E> void set_exception( char const * what ) // throw()
+  {
+    m_impl->template set_exception<E>( what );
+  }
+  */
+
+
+   bool cancel() volatile
+   {
+     if(!m_ready || m_executing)
+     {
+        m_is_cancelled = true;
+        return true;
+     }
+     else
+     {
+       return false;
+     }
+   }
+
+
+   bool is_cancelled() const volatile
+   {
+     return m_is_cancelled;
+   }
+
+
+   void set_execution_status(bool executing) volatile
+   {
+     m_executing = executing;
+   }
+};
+
+
+template<
+  template <typename> class Future,
+  typename Function
+>
+class future_impl_task_func
+{
+
+public:
+  typedef void result_type;                         //!< Indicates the functor's result type.
+
+  typedef Function function_type;                   //!< Indicates the function's type.
+  typedef typename result_of<function_type()>::type future_result_type; //!< Indicates the future's result type.
+  typedef Future<future_result_type> future_type;   //!< Indicates the future's type.
+
+  // The task is required to be a nullary function.
+  BOOST_STATIC_ASSERT(function_traits<function_type()>::arity == 0);
+
+  // The task function's result type is required not to be void.
+  BOOST_STATIC_ASSERT(!is_void<future_result_type>::value);
+
+private:
+  function_type             m_function;
+  shared_ptr<future_type>   m_future;
+
+public:
+  future_impl_task_func(function_type const & function, shared_ptr<future_type> const & future)
+  : m_function(function)
+  , m_future(future)
+  {
+  }
+
+  void operator()()
+  {
+    if(m_function)
+    {
+      m_future->set_execution_status(true);
+      if(!m_future->is_cancelled())
+      {
+        // TODO future exeception handling 
+        m_future->set_value(m_function());
+      }
+      m_future->set_execution_status(false); // TODO consider exceptions
+    }
+  }
+
+};
+
+
+
+
+
+} } } // namespace boost::threadpool::detail
+
+#endif // THREADPOOL_DETAIL_FUTURE_IMPL_HPP_INCLUDED
+
+

=== added file 'shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail/locking_ptr.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail/locking_ptr.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail/locking_ptr.hpp	2008-11-19 22:53:32 +0000
@@ -0,0 +1,85 @@
+/*! \file
+* \brief The locking_ptr is smart pointer with a scoped locking mechanism.
+*
+* The class is a wrapper for a volatile pointer. It enables synchronized access to the
+* internal pointer by locking the passed mutex.
+* locking_ptr is based on Andrei Alexandrescu's LockingPtr. For more information
+* see article "volatile - Multithreaded Programmer's Best Friend" by A. Alexandrescu.
+*
+*
+* Copyright (c) 2005-2007 Philipp Henkel
+*
+* Use, modification, and distribution are  subject to the
+* Boost Software License, Version 1.0. (See accompanying  file
+* LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+*
+* http://threadpool.sourceforge.net
+*
+*/
+
+
+#ifndef THREADPOOL_DETAIL_LOCKING_PTR_HPP_INCLUDED
+#define THREADPOOL_DETAIL_LOCKING_PTR_HPP_INCLUDED
+
+#include <boost/utility.hpp>
+#include <boost/thread/mutex.hpp>
+
+
+namespace boost { namespace threadpool { namespace detail 
+{
+
+/*! \brief  Smart pointer with a scoped locking mechanism.
+ *
+ * This class is a wrapper for a volatile pointer. It enables synchronized access to the
+ * internal pointer by locking the passed mutex.
+ */
+  template <typename T, typename Mutex>
+  class locking_ptr 
+  : private noncopyable
+  {
+    T* m_obj;                     //!< The instance pointer. 
+    Mutex & m_mutex;              //!< Mutex is used for scoped locking.
+
+  public:
+    /// Constructor.
+    locking_ptr(volatile T& obj, const volatile Mutex& mtx)
+      : m_obj(const_cast<T*>(&obj))
+      , m_mutex(*const_cast<Mutex*>(&mtx))
+    {   
+      // Lock mutex
+	  m_mutex.lock();
+    }
+
+
+    /// Destructor.
+    ~locking_ptr()
+    { 
+      // Unlock mutex
+      m_mutex.unlock();
+    }
+
+
+    /*! Returns a reference to the stored instance.
+    * \return The instance's reference.
+    */
+    T& operator*() const
+    {    
+      return *m_obj;    
+    }
+
+
+    /*! Returns a pointer to the stored instance.
+    * \return The instance's pointer.
+    */
+    T* operator->() const
+    {   
+      return m_obj;   
+    }
+  };
+
+
+} } } // namespace boost::threadpool::detail
+
+
+#endif // THREADPOOL_DETAIL_LOCKING_PTR_HPP_INCLUDED
+

=== added file 'shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail/pool_core.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail/pool_core.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail/pool_core.hpp	2008-11-19 22:25:44 +0000
@@ -0,0 +1,453 @@
+/*! \file
+* \brief Thread pool core.
+*
+* This file contains the threadpool's core class: pool<Task, SchedulingPolicy>.
+*
+* Thread pools are a mechanism for asynchronous and parallel processing 
+* within the same process. The pool class provides a convenient way 
+* for dispatching asynchronous tasks as functions objects. The scheduling
+* of these tasks can be easily controlled by using customized schedulers. 
+*
+* Copyright (c) 2005-2007 Philipp Henkel
+*
+* Use, modification, and distribution are  subject to the
+* Boost Software License, Version 1.0. (See accompanying  file
+* LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+*
+* http://threadpool.sourceforge.net
+*
+*/
+
+
+#ifndef THREADPOOL_POOL_CORE_HPP_INCLUDED
+#define THREADPOOL_POOL_CORE_HPP_INCLUDED
+
+
+
+
+#include "locking_ptr.hpp"
+#include "worker_thread.hpp"
+
+#include "../task_adaptors.hpp"
+
+#include <boost/thread.hpp>
+#include <boost/thread/exceptions.hpp>
+#include <boost/thread/mutex.hpp>
+#include <boost/thread/condition.hpp>
+#include <boost/smart_ptr.hpp>
+#include <boost/bind.hpp>
+#include <boost/static_assert.hpp>
+#include <boost/type_traits.hpp>
+
+#include <vector>
+
+
+/// The namespace threadpool contains a thread pool and related utility classes.
+namespace boost { namespace threadpool { namespace detail 
+{
+
+  /*! \brief Thread pool. 
+  *
+  * Thread pools are a mechanism for asynchronous and parallel processing 
+  * within the same process. The pool class provides a convenient way 
+  * for dispatching asynchronous tasks as functions objects. The scheduling
+  * of these tasks can be easily controlled by using customized schedulers. 
+  * A task must not throw an exception.
+  *
+  * A pool_impl is DefaultConstructible and NonCopyable.
+  *
+  * \param Task A function object which implements the operator 'void operator() (void) const'. The operator () is called by the pool to execute the task. Exceptions are ignored.
+  * \param Scheduler A task container which determines how tasks are scheduled. It is guaranteed that this container is accessed only by one thread at a time. The scheduler shall not throw exceptions.
+  *
+  * \remarks The pool class is thread-safe.
+  * 
+  * \see Tasks: task_func, prio_task_func
+  * \see Scheduling policies: fifo_scheduler, lifo_scheduler, prio_scheduler
+  */ 
+  template <
+    typename Task, 
+
+    template <typename> class SchedulingPolicy,
+    template <typename> class SizePolicy,
+    template <typename> class SizePolicyController,
+    template <typename> class ShutdownPolicy
+  > 
+  class pool_core
+  : public enable_shared_from_this< pool_core<Task, SchedulingPolicy, SizePolicy, SizePolicyController, ShutdownPolicy > > 
+  , private noncopyable
+  {
+
+  public: // Type definitions
+    typedef Task task_type;                                 //!< Indicates the task's type.
+    typedef SchedulingPolicy<task_type> scheduler_type;     //!< Indicates the scheduler's type.
+    typedef pool_core<Task, 
+                      SchedulingPolicy, 
+                      SizePolicy,
+                      SizePolicyController,
+                      ShutdownPolicy > pool_type;           //!< Indicates the thread pool's type.
+    typedef SizePolicy<pool_type> size_policy_type;         //!< Indicates the sizer's type.
+    //typedef typename size_policy_type::size_controller size_controller_type;
+
+    typedef SizePolicyController<pool_type> size_controller_type;
+
+//    typedef SizePolicy<pool_type>::size_controller size_controller_type;
+    typedef ShutdownPolicy<pool_type> shutdown_policy_type;//!< Indicates the shutdown policy's type.  
+
+    typedef worker_thread<pool_type> worker_type;
+
+    // The task is required to be a nullary function.
+    BOOST_STATIC_ASSERT(function_traits<task_type()>::arity == 0);
+
+    // The task function's result type is required to be void.
+    BOOST_STATIC_ASSERT(is_void<typename result_of<task_type()>::type >::value);
+
+
+  private:  // Friends 
+    friend class worker_thread<pool_type>;
+
+#if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x580)  // Tested with CC: Sun C++ 5.8 Patch 121018-08 2006/12/06
+   friend class SizePolicy;
+   friend class ShutdownPolicy;
+#else
+   friend class SizePolicy<pool_type>;
+   friend class ShutdownPolicy<pool_type>;
+#endif
+
+  private: // The following members may be accessed by _multiple_ threads at the same time:
+    volatile size_t m_worker_count;	
+    volatile size_t m_target_worker_count;	
+    volatile size_t m_active_worker_count;
+      
+
+
+  private: // The following members are accessed only by _one_ thread at the same time:
+    scheduler_type  m_scheduler;
+    scoped_ptr<size_policy_type> m_size_policy; // is never null
+    
+    bool  m_terminate_all_workers;								// Indicates if termination of all workers was triggered.
+    std::vector<shared_ptr<worker_type> > m_terminated_workers; // List of workers which are terminated but not fully destructed.
+    
+  private: // The following members are implemented thread-safe:
+    mutable recursive_mutex  m_monitor;
+    mutable condition m_worker_idle_or_terminated_event;	// A worker is idle or was terminated.
+    mutable condition m_task_or_terminate_workers_event;  // Task is available OR total worker count should be reduced.
+
+  public:
+    /// Constructor.
+    pool_core()
+      : m_worker_count(0) 
+      , m_target_worker_count(0)
+      , m_active_worker_count(0)
+      , m_terminate_all_workers(false)
+    {
+      pool_type volatile & self_ref = *this;
+      m_size_policy.reset(new size_policy_type(self_ref));
+
+      m_scheduler.clear();
+    }
+
+
+    /// Destructor.
+    ~pool_core()
+    {
+    }
+
+    /*! Gets the size controller which manages the number of threads in the pool. 
+    * \return The size controller.
+    * \see SizePolicy
+    */
+    size_controller_type size_controller()
+    {
+      return size_controller_type(*m_size_policy, this->shared_from_this());
+    }
+
+    /*! Gets the number of threads in the pool.
+    * \return The number of threads.
+    */
+    size_t size()	const volatile
+    {
+      return m_worker_count;
+    }
+
+// TODO is only called once
+    void shutdown()
+    {
+      ShutdownPolicy<pool_type>::shutdown(*this);
+    }
+
+    /*! Schedules a task for asynchronous execution. The task will be executed once only.
+    * \param task The task function object. It should not throw execeptions.
+    * \return true, if the task could be scheduled and false otherwise. 
+    */  
+    bool schedule(task_type const & task) volatile
+    {	
+      locking_ptr<pool_type, recursive_mutex> lockedThis(*this, m_monitor); 
+      
+      if(lockedThis->m_scheduler.push(task))
+      {
+        lockedThis->m_task_or_terminate_workers_event.notify_one();
+        return true;
+      }
+      else
+      {
+        return false;
+      }
+    }	
+
+
+    /*! Returns the number of tasks which are currently executed.
+    * \return The number of active tasks. 
+    */  
+    size_t active() const volatile
+    {
+      return m_active_worker_count;
+    }
+
+
+    /*! Returns the number of tasks which are ready for execution.    
+    * \return The number of pending tasks. 
+    */  
+    size_t pending() const volatile
+    {
+      locking_ptr<const pool_type, recursive_mutex> lockedThis(*this, m_monitor);
+      return lockedThis->m_scheduler.size();
+    }
+
+
+    /*! Removes all pending tasks from the pool's scheduler.
+    */  
+    void clear() volatile
+    { 
+      locking_ptr<pool_type, recursive_mutex> lockedThis(*this, m_monitor);
+      lockedThis->m_scheduler.clear();
+    }    
+
+
+    /*! Indicates that there are no tasks pending. 
+    * \return true if there are no tasks ready for execution.	
+    * \remarks This function is more efficient that the check 'pending() == 0'.
+    */   
+    bool empty() const volatile
+    {
+      locking_ptr<const pool_type, recursive_mutex> lockedThis(*this, m_monitor);
+      return lockedThis->m_scheduler.empty();
+    }	
+
+
+    /*! The current thread of execution is blocked until the sum of all active
+    *  and pending tasks is equal or less than a given threshold. 
+    * \param task_threshold The maximum number of tasks in pool and scheduler.
+    */     
+    void wait(size_t const task_threshold = 0) const volatile
+    {
+      const pool_type* self = const_cast<const pool_type*>(this);
+      recursive_mutex::scoped_lock lock(self->m_monitor);
+
+      if(0 == task_threshold)
+      {
+        while(0 != self->m_active_worker_count || !self->m_scheduler.empty())
+        { 
+          self->m_worker_idle_or_terminated_event.wait(lock);
+        }
+      }
+      else
+      {
+        while(task_threshold < self->m_active_worker_count + self->m_scheduler.size())
+        { 
+          self->m_worker_idle_or_terminated_event.wait(lock);
+        }
+      }
+    }	
+
+    /*! The current thread of execution is blocked until the timestamp is met
+    * or the sum of all active and pending tasks is equal or less 
+    * than a given threshold.  
+    * \param timestamp The time when function returns at the latest.
+    * \param task_threshold The maximum number of tasks in pool and scheduler.
+    * \return true if the task sum is equal or less than the threshold, false otherwise.
+    */       
+    bool wait(xtime const & timestamp, size_t const task_threshold = 0) const volatile
+    {
+      const pool_type* self = const_cast<const pool_type*>(this);
+      recursive_mutex::scoped_lock lock(self->m_monitor);
+
+      if(0 == task_threshold)
+      {
+        while(0 != self->m_active_worker_count || !self->m_scheduler.empty())
+        { 
+          if(!self->m_worker_idle_or_terminated_event.timed_wait(lock, timestamp)) return false;
+        }
+      }
+      else
+      {
+        while(task_threshold < self->m_active_worker_count + self->m_scheduler.size())
+        { 
+          if(!self->m_worker_idle_or_terminated_event.timed_wait(lock, timestamp)) return false;
+        }
+      }
+
+      return true;
+    }
+
+
+  private:	
+
+
+    void terminate_all_workers(bool const wait) volatile
+    {
+      pool_type* self = const_cast<pool_type*>(this);
+      recursive_mutex::scoped_lock lock(self->m_monitor);
+
+      self->m_terminate_all_workers = true;
+
+      m_target_worker_count = 0;
+      self->m_task_or_terminate_workers_event.notify_all();
+
+      if(wait)
+      {
+        while(m_active_worker_count > 0)
+        {
+          self->m_worker_idle_or_terminated_event.wait(lock);
+        }
+
+        for(typename std::vector<shared_ptr<worker_type> >::iterator it = self->m_terminated_workers.begin();
+          it != self->m_terminated_workers.end();
+          ++it)
+        {
+          (*it)->join();
+        }
+        self->m_terminated_workers.clear();
+      }
+    }
+
+
+    /*! Changes the number of worker threads in the pool. The resizing 
+    *  is handled by the SizePolicy.
+    * \param threads The new number of worker threads.
+    * \return true, if pool will be resized and false if not. 
+    */
+    bool resize(size_t const worker_count) volatile
+    {
+      locking_ptr<pool_type, recursive_mutex> lockedThis(*this, m_monitor); 
+
+      if(!m_terminate_all_workers)
+      {
+        m_target_worker_count = worker_count;
+      }
+      else
+      { 
+        return false;
+      }
+
+
+      if(m_worker_count <= m_target_worker_count)
+      { // increase worker count
+        while(m_worker_count < m_target_worker_count)
+        {
+          try
+          {
+            worker_thread<pool_type>::create_and_attach(lockedThis->shared_from_this());
+            m_worker_count++;
+            m_active_worker_count++;	
+          }
+          catch(thread_resource_error)
+          {
+            return false;
+          }
+        }
+      }
+      else
+      { // decrease worker count
+        lockedThis->m_task_or_terminate_workers_event.notify_all();   // TODO: Optimize number of notified workers
+      }
+
+      return true;
+    }
+
+
+    // worker died with unhandled exception
+    void worker_died_unexpectedly(shared_ptr<worker_type> worker) volatile
+    {
+      locking_ptr<pool_type, recursive_mutex> lockedThis(*this, m_monitor);
+
+      m_worker_count--;
+      m_active_worker_count--;
+      lockedThis->m_worker_idle_or_terminated_event.notify_all();	
+
+      if(m_terminate_all_workers)
+      {
+        lockedThis->m_terminated_workers.push_back(worker);
+      }
+      else
+      {
+        lockedThis->m_size_policy->worker_died_unexpectedly(m_worker_count);
+      }
+    }
+
+    void worker_destructed(shared_ptr<worker_type> worker) volatile
+    {
+      locking_ptr<pool_type, recursive_mutex> lockedThis(*this, m_monitor);
+      m_worker_count--;
+      m_active_worker_count--;
+      lockedThis->m_worker_idle_or_terminated_event.notify_all();	
+
+      if(m_terminate_all_workers)
+      {
+        lockedThis->m_terminated_workers.push_back(worker);
+      }
+    }
+
+
+    bool execute_task() volatile
+    {
+      function0<void> task;
+
+      { // fetch task
+        pool_type* lockedThis = const_cast<pool_type*>(this);
+        recursive_mutex::scoped_lock lock(lockedThis->m_monitor);
+
+        // decrease number of threads if necessary
+        if(m_worker_count > m_target_worker_count)
+        {	
+          return false;	// terminate worker
+        }
+
+
+        // wait for tasks
+        while(lockedThis->m_scheduler.empty())
+        {	
+          // decrease number of workers if necessary
+          if(m_worker_count > m_target_worker_count)
+          {	
+            return false;	// terminate worker
+          }
+          else
+          {
+            m_active_worker_count--;
+            lockedThis->m_worker_idle_or_terminated_event.notify_all();	
+            lockedThis->m_task_or_terminate_workers_event.wait(lock);
+            m_active_worker_count++;
+          }
+        }
+
+        task = lockedThis->m_scheduler.top();
+        lockedThis->m_scheduler.pop();
+      }
+
+      // call task function
+      if(task)
+      {
+        task();
+      }
+ 
+      //guard->disable();
+      return true;
+    }
+  };
+
+
+
+
+} } } // namespace boost::threadpool::detail
+
+#endif // THREADPOOL_POOL_CORE_HPP_INCLUDED

=== added file 'shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail/scope_guard.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail/scope_guard.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail/scope_guard.hpp	2007-11-21 00:01:14 +0000
@@ -0,0 +1,65 @@
+/*! \file
+* \brief TODO.
+*
+* TODO. 
+*
+* Copyright (c) 2005-2007 Philipp Henkel
+*
+* Use, modification, and distribution are  subject to the
+* Boost Software License, Version 1.0. (See accompanying  file
+* LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+*
+* http://threadpool.sourceforge.net
+*
+*/
+
+
+#ifndef THREADPOOL_DETAIL_SCOPE_GUARD_HPP_INCLUDED
+#define THREADPOOL_DETAIL_SCOPE_GUARD_HPP_INCLUDED
+
+
+
+#include <boost/function.hpp>
+
+
+namespace boost { namespace threadpool { namespace detail 
+{
+
+// TODO documentation
+class scope_guard
+: private boost::noncopyable
+{
+	function0<void> const m_function;
+	bool                  m_is_active;
+
+public:
+	scope_guard(function0<void> const & call_on_exit)
+	: m_function(call_on_exit)
+	, m_is_active(true)
+	{
+	}
+
+	~scope_guard()
+	{
+		if(m_is_active && m_function)
+		{
+			m_function();
+		}
+	}
+
+	void disable()
+	{
+		m_is_active = false;
+	}
+};
+
+
+
+
+
+
+} } } // namespace boost::threadpool::detail
+
+#endif // THREADPOOL_DETAIL_SCOPE_GUARD_HPP_INCLUDED
+
+

=== added file 'shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail/worker_thread.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail/worker_thread.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/detail/worker_thread.hpp	2007-11-21 23:00:50 +0000
@@ -0,0 +1,115 @@
+/*! \file
+* \brief Thread pool worker.
+*
+* The worker thread instance is attached to a pool 
+* and executes tasks of this pool. 
+*
+* Copyright (c) 2005-2007 Philipp Henkel
+*
+* Use, modification, and distribution are  subject to the
+* Boost Software License, Version 1.0. (See accompanying  file
+* LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+*
+* http://threadpool.sourceforge.net
+*
+*/
+
+#ifndef THREADPOOL_DETAIL_WORKER_THREAD_HPP_INCLUDED
+#define THREADPOOL_DETAIL_WORKER_THREAD_HPP_INCLUDED
+
+
+#include "scope_guard.hpp"
+
+#include <boost/smart_ptr.hpp>
+#include <boost/thread.hpp>
+#include <boost/thread/exceptions.hpp>
+#include <boost/thread/mutex.hpp>
+#include <boost/bind.hpp>
+
+
+namespace boost { namespace threadpool { namespace detail 
+{
+
+  /*! \brief Thread pool worker. 
+  *
+  * A worker_thread represents a thread of execution. The worker is attached to a 
+  * thread pool and processes tasks of that pool. The lifetime of the worker and its 
+  * internal boost::thread is managed automatically.
+  *
+  * This class is a helper class and cannot be constructed or accessed directly.
+  * 
+  * \see pool_core
+  */ 
+  template <typename Pool>
+  class worker_thread
+  : public enable_shared_from_this< worker_thread<Pool> > 
+  , private noncopyable
+  {
+  public:
+    typedef Pool pool_type;         	   //!< Indicates the pool's type.
+
+  private:
+    shared_ptr<pool_type>      m_pool;     //!< Pointer to the pool which created the worker.
+    shared_ptr<boost::thread>  m_thread;   //!< Pointer to the thread which executes the run loop.
+
+    
+    /*! Constructs a new worker. 
+    * \param pool Pointer to it's parent pool.
+    * \see function create_and_attach
+    */
+    worker_thread(shared_ptr<pool_type> const & pool)
+    : m_pool(pool)
+    {
+      assert(pool);
+    }
+
+	
+	/*! Notifies that an exception occurred in the run loop.
+	*/
+	void died_unexpectedly()
+	{
+		m_pool->worker_died_unexpectedly(this->shared_from_this());
+	}
+
+
+  public:
+	  /*! Executes pool's tasks sequentially.
+	  */
+	  void run()
+	  { 
+		  scope_guard notify_exception(bind(&worker_thread::died_unexpectedly, this));
+
+		  while(m_pool->execute_task()) {}
+
+		  notify_exception.disable();
+		  m_pool->worker_destructed(this->shared_from_this());
+	  }
+
+
+	  /*! Joins the worker's thread.
+	  */
+	  void join()
+	  {
+		  m_thread->join();
+	  }
+
+
+	  /*! Constructs a new worker thread and attaches it to the pool.
+	  * \param pool Pointer to the pool.
+	  */
+	  static void create_and_attach(shared_ptr<pool_type> const & pool)
+	  {
+		  shared_ptr<worker_thread> worker(new worker_thread(pool));
+		  if(worker)
+		  {
+			  worker->m_thread.reset(new boost::thread(bind(&worker_thread::run, worker)));
+		  }
+	  }
+
+  };
+
+
+} } } // namespace boost::threadpool::detail
+
+#endif // THREADPOOL_DETAIL_WORKER_THREAD_HPP_INCLUDED
+

=== added file 'shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/future.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/future.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/future.hpp	2007-11-21 23:00:16 +0000
@@ -0,0 +1,144 @@
+/*! \file
+* \brief TODO.
+*
+* TODO. 
+*
+* Copyright (c) 2005-2007 Philipp Henkel
+*
+* Use, modification, and distribution are  subject to the
+* Boost Software License, Version 1.0. (See accompanying  file
+* LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+*
+* http://threadpool.sourceforge.net
+*
+*/
+
+#ifndef THREADPOOL_FUTURE_HPP_INCLUDED
+#define THREADPOOL_FUTURE_HPP_INCLUDED
+
+
+  
+#include "./detail/future.hpp"
+#include <boost/utility/enable_if.hpp>
+
+//#include "pool.hpp"
+//#include <boost/utility.hpp>
+
+//#include <boost/thread/mutex.hpp>
+
+
+namespace boost { namespace threadpool
+{
+
+  /*! \brief Experimental. Do not use in production code. TODO. 
+  *
+  * TODO Future
+  *
+  * \see TODO
+  *
+  */ 
+
+
+template<class Result> 
+class future
+{
+private:
+  shared_ptr<detail::future_impl<Result> > m_impl;
+
+public:
+    typedef Result const & result_type; //!< Indicates the functor's result type.
+    typedef Result future_result_type; //!< Indicates the future's result type.
+
+
+public:
+
+  future()
+  : m_impl(new detail::future_impl<future_result_type>()) // TODO remove this
+  {
+  }
+
+  // only for internal usage
+  future(shared_ptr<detail::future_impl<Result> > const & impl)
+  : m_impl(impl)
+  {
+  }
+
+  bool ready() const
+  {
+    return m_impl->ready();
+  }
+
+  void wait() const
+  {
+    m_impl->wait();
+  }
+
+  bool timed_wait(boost::xtime const & timestamp) const
+  {
+    return m_impl->timed_wait(timestamp);
+  }
+
+   result_type operator()() // throw( thread::cancelation_exception, ... )
+   {
+     return (*m_impl)();
+   }
+
+   result_type get() // throw( thread::cancelation_exception, ... )
+   {
+     return (*m_impl)();
+   }
+
+   bool cancel()
+   {
+     return m_impl->cancel();
+   }
+
+   bool is_cancelled() const
+   {
+     return m_impl->is_cancelled();
+   }
+};
+
+
+
+
+
+template<class Pool, class Function>
+typename disable_if < 
+  is_void< typename result_of< Function() >::type >,
+  future< typename result_of< Function() >::type >
+>::type
+schedule(Pool& pool, const Function& task)
+{
+  typedef typename result_of< Function() >::type future_result_type;
+
+  // create future impl and future
+  shared_ptr<detail::future_impl<future_result_type> > impl(new detail::future_impl<future_result_type>);
+  future <future_result_type> res(impl);
+
+  // schedule future impl
+  pool.schedule(detail::future_impl_task_func<detail::future_impl, Function>(task, impl));
+
+  // return future
+  return res;
+
+/*
+ TODO
+  if(pool->schedule(bind(&Future::run, future)))
+  {
+    return future;
+  }
+  else
+  {
+    // construct empty future
+    return error_future;
+  }
+  */
+}
+
+
+
+} } // namespace boost::threadpool
+
+#endif // THREADPOOL_FUTURE_HPP_INCLUDED
+

=== added file 'shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/pool.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/pool.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/pool.hpp	2007-11-21 23:00:16 +0000
@@ -0,0 +1,232 @@
+/*! \file
+* \brief Thread pool core.
+*
+* This file contains the threadpool's core class: pool<Task, SchedulingPolicy>.
+*
+* Thread pools are a mechanism for asynchronous and parallel processing 
+* within the same process. The pool class provides a convenient way 
+* for dispatching asynchronous tasks as functions objects. The scheduling
+* of these tasks can be easily controlled by using customized schedulers. 
+*
+* Copyright (c) 2005-2007 Philipp Henkel
+*
+* Use, modification, and distribution are  subject to the
+* Boost Software License, Version 1.0. (See accompanying  file
+* LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+*
+* http://threadpool.sourceforge.net
+*
+*/
+
+
+#ifndef THREADPOOL_POOL_HPP_INCLUDED
+#define THREADPOOL_POOL_HPP_INCLUDED
+
+#include <boost/ref.hpp>
+
+#include "./detail/pool_core.hpp"
+
+#include "task_adaptors.hpp"
+
+#include "./detail/locking_ptr.hpp"
+
+#include "scheduling_policies.hpp"
+#include "size_policies.hpp"
+#include "shutdown_policies.hpp"
+
+
+
+/// The namespace threadpool contains a thread pool and related utility classes.
+namespace boost { namespace threadpool
+{
+
+
+
+  /*! \brief Thread pool. 
+  *
+  * Thread pools are a mechanism for asynchronous and parallel processing 
+  * within the same process. The pool class provides a convenient way 
+  * for dispatching asynchronous tasks as functions objects. The scheduling
+  * of these tasks can be easily controlled by using customized schedulers. 
+  * A task must not throw an exception.
+  *
+  * A pool is DefaultConstructible, CopyConstructible and Assignable.
+  * It has reference semantics; all copies of the same pool are equivalent and interchangeable. 
+  * All operations on a pool except assignment are strongly thread safe or sequentially consistent; 
+  * that is, the behavior of concurrent calls is as if the calls have been issued sequentially in an unspecified order.
+  *
+  * \param Task A function object which implements the operator 'void operator() (void) const'. The operator () is called by the pool to execute the task. Exceptions are ignored.
+  * \param SchedulingPolicy A task container which determines how tasks are scheduled. It is guaranteed that this container is accessed only by one thread at a time. The scheduler shall not throw exceptions.
+  *
+  * \remarks The pool class is thread-safe.
+  * 
+  * \see Tasks: task_func, prio_task_func
+  * \see Scheduling policies: fifo_scheduler, lifo_scheduler, prio_scheduler
+  */ 
+  template <
+    typename Task                                   = task_func,
+    template <typename> class SchedulingPolicy      = fifo_scheduler,
+    template <typename> class SizePolicy            = static_size,
+    template <typename> class SizePolicyController  = resize_controller,
+    template <typename> class ShutdownPolicy        = wait_for_all_tasks
+  > 
+  class thread_pool 
+  {
+    typedef detail::pool_core<Task, 
+                              SchedulingPolicy,
+                              SizePolicy,
+                              SizePolicyController,
+                              ShutdownPolicy> pool_core_type;
+    shared_ptr<pool_core_type>          m_core; // pimpl idiom
+    shared_ptr<void>                    m_shutdown_controller; // If the last pool holding a pointer to the core is deleted the controller shuts the pool down.
+
+  public: // Type definitions
+    typedef Task task_type;                                   //!< Indicates the task's type.
+    typedef SchedulingPolicy<task_type> scheduler_type;       //!< Indicates the scheduler's type.
+ /*   typedef thread_pool<Task, 
+                        SchedulingPolicy,
+                        SizePolicy,
+                        ShutdownPolicy > pool_type;          //!< Indicates the thread pool's type.
+ */
+    typedef SizePolicy<pool_core_type> size_policy_type; 
+    typedef SizePolicyController<pool_core_type> size_controller_type;
+
+
+  public:
+    /*! Constructor.
+     * \param initial_threads The pool is immediately resized to set the specified number of threads. The pool's actual number threads depends on the SizePolicy.
+     */
+    thread_pool(size_t initial_threads = 0)
+    : m_core(new pool_core_type)
+    , m_shutdown_controller(static_cast<void*>(0), bind(&pool_core_type::shutdown, m_core))
+    {
+      size_policy_type::init(*m_core, initial_threads);
+    }
+
+
+    /*! Gets the size controller which manages the number of threads in the pool. 
+    * \return The size controller.
+    * \see SizePolicy
+    */
+    size_controller_type size_controller()
+    {
+      return m_core->size_controller();
+    }
+
+
+    /*! Gets the number of threads in the pool.
+    * \return The number of threads.
+    */
+    size_t size()	const
+    {
+      return m_core->size();
+    }
+
+
+     /*! Schedules a task for asynchronous execution. The task will be executed once only.
+     * \param task The task function object. It should not throw execeptions.
+     * \return true, if the task could be scheduled and false otherwise. 
+     */  
+     bool schedule(task_type const & task)
+     {	
+       return m_core->schedule(task);
+     }
+
+
+    /*! Returns the number of tasks which are currently executed.
+    * \return The number of active tasks. 
+    */  
+    size_t active() const
+    {
+      return m_core->active();
+    }
+
+
+    /*! Returns the number of tasks which are ready for execution.    
+    * \return The number of pending tasks. 
+    */  
+    size_t pending() const
+    {
+      return m_core->pending();
+    }
+
+
+    /*! Removes all pending tasks from the pool's scheduler.
+    */  
+    void clear()
+    { 
+      m_core->clear();
+    }    
+
+
+    /*! Indicates that there are no tasks pending. 
+    * \return true if there are no tasks ready for execution.	
+    * \remarks This function is more efficient that the check 'pending() == 0'.
+    */   
+    bool empty() const
+    {
+      return m_core->empty();
+    }	
+
+
+    /*! The current thread of execution is blocked until the sum of all active
+    *  and pending tasks is equal or less than a given threshold. 
+    * \param task_threshold The maximum number of tasks in pool and scheduler.
+    */     
+    void wait(size_t task_threshold = 0) const
+    {
+      m_core->wait(task_threshold);
+    }	
+
+
+    /*! The current thread of execution is blocked until the timestamp is met
+    * or the sum of all active and pending tasks is equal or less 
+    * than a given threshold.  
+    * \param timestamp The time when function returns at the latest.
+    * \param task_threshold The maximum number of tasks in pool and scheduler.
+    * \return true if the task sum is equal or less than the threshold, false otherwise.
+    */       
+    bool wait(xtime const & timestamp, size_t task_threshold = 0) const
+    {
+      return m_core->wait(timestamp, task_threshold);
+    }
+  };
+
+
+
+  /*! \brief Fifo pool.
+  *
+  * The pool's tasks are fifo scheduled task_func functors.
+  *
+  */ 
+  typedef thread_pool<task_func, fifo_scheduler, static_size, resize_controller, wait_for_all_tasks> fifo_pool;
+
+
+  /*! \brief Lifo pool.
+  *
+  * The pool's tasks are lifo scheduled task_func functors.
+  *
+  */ 
+  typedef thread_pool<task_func, lifo_scheduler, static_size, resize_controller, wait_for_all_tasks> lifo_pool;
+
+
+  /*! \brief Pool for prioritized task.
+  *
+  * The pool's tasks are prioritized prio_task_func functors.
+  *
+  */ 
+  typedef thread_pool<prio_task_func, prio_scheduler, static_size, resize_controller, wait_for_all_tasks> prio_pool;
+
+
+  /*! \brief A standard pool.
+  *
+  * The pool's tasks are fifo scheduled task_func functors.
+  *
+  */ 
+  typedef fifo_pool pool;
+
+
+
+} } // namespace boost::threadpool
+
+#endif // THREADPOOL_POOL_HPP_INCLUDED

=== added file 'shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/pool_adaptors.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/pool_adaptors.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/pool_adaptors.hpp	2007-11-21 00:01:12 +0000
@@ -0,0 +1,70 @@
+/*! \file
+* \brief Pool adaptors.
+*
+* This file contains an easy-to-use adaptor similar to a smart 
+* pointer for the pool class. 
+*
+* Copyright (c) 2005-2007 Philipp Henkel
+*
+* Use, modification, and distribution are  subject to the
+* Boost Software License, Version 1.0. (See accompanying  file
+* LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+*
+* http://threadpool.sourceforge.net
+*
+*/
+
+
+#ifndef THREADPOOL_POOL_ADAPTORS_HPP_INCLUDED
+#define THREADPOOL_POOL_ADAPTORS_HPP_INCLUDED
+
+#include <boost/smart_ptr.hpp>
+
+
+namespace boost { namespace threadpool
+{
+
+
+// TODO convenience scheduling function
+    /*! Schedules a Runnable for asynchronous execution. A Runnable is an arbitrary class with a run()
+    * member function. This a convenience shorthand for pool->schedule(bind(&Runnable::run, task_object)).
+    * \param 
+    * \param obj The Runnable object. The member function run() will be exectued and should not throw execeptions.
+    * \return true, if the task could be scheduled and false otherwise. 
+    */  
+    template<typename Pool, typename Runnable>
+    bool schedule(Pool& pool, shared_ptr<Runnable> const & obj)
+    {	
+      return pool->schedule(bind(&Runnable::run, obj));
+    }	
+    
+    /*! Schedules a task for asynchronous execution. The task will be executed once only.
+    * \param task The task function object.
+    */  
+    template<typename Pool>
+    typename enable_if < 
+      is_void< typename result_of< typename Pool::task_type() >::type >,
+      bool
+    >::type
+    schedule(Pool& pool, typename Pool::task_type const & task)
+    {	
+      return pool.schedule(task);
+    }	
+
+
+    template<typename Pool>
+    typename enable_if < 
+      is_void< typename result_of< typename Pool::task_type() >::type >,
+      bool
+    >::type
+    schedule(shared_ptr<Pool> const pool, typename Pool::task_type const & task)
+    {	
+      return pool->schedule(task);
+    }	
+
+
+} } // namespace boost::threadpool
+
+#endif // THREADPOOL_POOL_ADAPTORS_HPP_INCLUDED
+
+

=== added file 'shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/scheduling_policies.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/scheduling_policies.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/scheduling_policies.hpp	2007-11-21 23:00:50 +0000
@@ -0,0 +1,262 @@
+/*! \file
+* \brief Task scheduling policies.
+*
+* This file contains some fundamental scheduling policies for the pool class. 
+* A scheduling policy is realized by a task container which controls the access to
+* the tasks. 	Fundamentally the container determines the order the tasks are processed
+* by the thread pool. 
+* The task containers need not to be thread-safe because they are used by the pool 
+* in thread-safe way. 
+*
+* Copyright (c) 2005-2007 Philipp Henkel
+*
+* Use, modification, and distribution are  subject to the
+* Boost Software License, Version 1.0. (See accompanying  file
+* LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+*
+* http://threadpool.sourceforge.net
+*
+*/
+
+
+#ifndef THREADPOOL_SCHEDULING_POLICIES_HPP_INCLUDED
+#define THREADPOOL_SCHEDULING_POLICIES_HPP_INCLUDED
+
+
+#include <queue>
+#include <deque>
+
+#include "task_adaptors.hpp"
+
+namespace boost { namespace threadpool
+{
+
+  /*! \brief SchedulingPolicy which implements FIFO ordering. 
+  *
+  * This container implements a FIFO scheduling policy.
+  * The first task to be added to the scheduler will be the first to be removed.
+  * The processing proceeds sequentially in the same order. 
+  * FIFO stands for "first in, first out".
+  *
+  * \param Task A function object which implements the operator()(void).
+  *
+  */ 
+  template <typename Task = task_func>  
+  class fifo_scheduler
+  {
+  public:
+    typedef Task task_type; //!< Indicates the scheduler's task type.
+
+  protected:
+    std::deque<task_type> m_container;  //!< Internal task container.	
+
+
+  public:
+    /*! Adds a new task to the scheduler.
+    * \param task The task object.
+    * \return true, if the task could be scheduled and false otherwise. 
+    */
+    bool push(task_type const & task)
+    {
+      m_container.push_back(task);
+      return true;
+    }
+
+    /*! Removes the task which should be executed next.
+    */
+    void pop()
+    {
+      m_container.pop_front();
+    }
+
+    /*! Gets the task which should be executed next.
+    *  \return The task object to be executed.
+    */
+    task_type const & top() const
+    {
+      return m_container.front();
+    }
+
+    /*! Gets the current number of tasks in the scheduler.
+    *  \return The number of tasks.
+    *  \remarks Prefer empty() to size() == 0 to check if the scheduler is empty.
+    */
+    size_t size() const
+    {
+      return m_container.size();
+    }
+
+    /*! Checks if the scheduler is empty.
+    *  \return true if the scheduler contains no tasks, false otherwise.
+    *  \remarks Is more efficient than size() == 0. 
+    */
+    bool empty() const
+    {
+      return m_container.empty();
+    }
+
+    /*! Removes all tasks from the scheduler.
+    */  
+    void clear()
+    {   
+      m_container.clear();
+    } 
+  };
+
+
+
+  /*! \brief SchedulingPolicy which implements LIFO ordering. 
+  *
+  * This container implements a LIFO scheduling policy.
+  * The last task to be added to the scheduler will be the first to be removed.
+  * LIFO stands for "last in, first out".
+  *
+  * \param Task A function object which implements the operator()(void).
+  *
+  */ 
+  template <typename Task = task_func>  
+  class lifo_scheduler
+  {
+  public:
+    typedef Task task_type;  //!< Indicates the scheduler's task type.
+
+  protected:
+    std::deque<task_type> m_container;  //!< Internal task container.	
+
+  public:
+    /*! Adds a new task to the scheduler.
+    * \param task The task object.
+    * \return true, if the task could be scheduled and false otherwise. 
+    */
+    bool push(task_type const & task)
+    {
+      m_container.push_front(task);
+      return true;
+    }
+
+    /*! Removes the task which should be executed next.
+    */
+    void pop()
+    {
+      m_container.pop_front();
+    }
+
+    /*! Gets the task which should be executed next.
+    *  \return The task object to be executed.
+    */
+    task_type const & top() const
+    {
+      return m_container.front();
+    }
+
+    /*! Gets the current number of tasks in the scheduler.
+    *  \return The number of tasks.
+    *  \remarks Prefer empty() to size() == 0 to check if the scheduler is empty.
+    */
+    size_t size() const
+    {
+      return m_container.size();
+    }
+
+    /*! Checks if the scheduler is empty.
+    *  \return true if the scheduler contains no tasks, false otherwise.
+    *  \remarks Is more efficient than size() == 0. 
+    */
+    bool empty() const
+    {
+      return m_container.empty();
+    }
+
+    /*! Removes all tasks from the scheduler.
+    */  
+    void clear()
+    {    
+      m_container.clear();
+    } 
+
+  };
+
+
+
+  /*! \brief SchedulingPolicy which implements prioritized ordering. 
+  *
+  * This container implements a scheduling policy based on task priorities.
+  * The task with highest priority will be the first to be removed.
+  * It must be possible to compare two tasks using operator<. 
+  *
+  * \param Task A function object which implements the operator() and operator<. operator< must be a partial ordering.
+  *
+  * \see prio_thread_func
+  *
+  */ 
+  template <typename Task = prio_task_func>  
+  class prio_scheduler
+  {
+  public:
+    typedef Task task_type; //!< Indicates the scheduler's task type.
+
+  protected:
+    std::priority_queue<task_type> m_container;  //!< Internal task container.
+
+
+  public:
+    /*! Adds a new task to the scheduler.
+    * \param task The task object.
+    * \return true, if the task could be scheduled and false otherwise. 
+    */
+    bool push(task_type const & task)
+    {
+      m_container.push(task);
+      return true;
+    }
+
+    /*! Removes the task which should be executed next.
+    */
+    void pop()
+    {
+      m_container.pop();
+    }
+
+    /*! Gets the task which should be executed next.
+    *  \return The task object to be executed.
+    */
+    task_type const & top() const
+    {
+      return m_container.top();
+    }
+
+    /*! Gets the current number of tasks in the scheduler.
+    *  \return The number of tasks.
+    *  \remarks Prefer empty() to size() == 0 to check if the scheduler is empty.
+    */
+    size_t size() const
+    {
+      return m_container.size();
+    }
+
+    /*! Checks if the scheduler is empty.
+    *  \return true if the scheduler contains no tasks, false otherwise.
+    *  \remarks Is more efficient than size() == 0. 
+    */
+    bool empty() const
+    {
+      return m_container.empty();
+    }
+
+    /*! Removes all tasks from the scheduler.
+    */  
+    void clear()
+    {    
+      while(!m_container.empty())
+      {
+        m_container.pop();
+      }
+    } 
+  };
+
+
+} } // namespace boost::threadpool
+
+
+#endif // THREADPOOL_SCHEDULING_POLICIES_HPP_INCLUDED
+

=== added file 'shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/shutdown_policies.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/shutdown_policies.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/shutdown_policies.hpp	2007-11-21 00:01:12 +0000
@@ -0,0 +1,83 @@
+/*! \file
+* \brief Shutdown policies.
+*
+* This file contains shutdown policies for thread_pool. 
+* A shutdown policy controls the pool's behavior from the time
+* when the pool is not referenced any longer.
+*
+* Copyright (c) 2005-2007 Philipp Henkel
+*
+* Use, modification, and distribution are  subject to the
+* Boost Software License, Version 1.0. (See accompanying  file
+* LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+*
+* http://threadpool.sourceforge.net
+*
+*/
+
+
+#ifndef THREADPOOL_SHUTDOWN_POLICIES_HPP_INCLUDED
+#define THREADPOOL_SHUTDOWN_POLICIES_HPP_INCLUDED
+
+
+
+/// The namespace threadpool contains a thread pool and related utility classes.
+namespace boost { namespace threadpool
+{
+
+
+/*! \brief ShutdownPolicy which waits for the completion of all tasks 
+  *          and the worker termination afterwards.
+    *
+  * \param Pool The pool's core type.
+  */ 
+  template<typename Pool>
+  class wait_for_all_tasks
+  {
+  public:
+    static void shutdown(Pool& pool)
+    {
+      pool.wait();
+      pool.terminate_all_workers(true);
+    }
+  };
+
+
+  /*! \brief ShutdownPolicy which waits for the completion of all active tasks 
+  *          and the worker termination afterwards.
+  *
+  * \param Pool The pool's core type.
+  */ 
+  template<typename Pool>
+  class wait_for_active_tasks
+  {
+  public:
+    static void shutdown(Pool& pool)
+    {
+      pool.clear();
+      pool.wait();
+      pool.terminate_all_workers(true);
+    }
+  };
+
+
+  /*! \brief ShutdownPolicy which does not wait for any tasks or worker termination.
+  *
+  * This policy does not wait for any tasks. Nevertheless all active tasks will be processed completely.
+  *
+  * \param Pool The pool's core type.
+  */ 
+  template<typename Pool>
+  class immediately
+  {
+  public:
+    static void shutdown(Pool& pool)
+    {
+      pool.clear();
+      pool.terminate_all_workers(false);
+    }
+  };
+
+} } // namespace boost::threadpool
+
+#endif // THREADPOOL_SHUTDOWN_POLICIES_HPP_INCLUDED

=== added file 'shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/size_policies.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/size_policies.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/size_policies.hpp	2007-11-21 00:01:12 +0000
@@ -0,0 +1,99 @@
+/*! \file
+* \brief Size policies.
+*
+* This file contains size policies for thread_pool. A size 
+* policy controls the number of worker threads in the pool.
+*
+* Copyright (c) 2005-2007 Philipp Henkel
+*
+* Use, modification, and distribution are  subject to the
+* Boost Software License, Version 1.0. (See accompanying  file
+* LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+*
+* http://threadpool.sourceforge.net
+*
+*/
+
+
+#ifndef THREADPOOL_SIZE_POLICIES_HPP_INCLUDED
+#define THREADPOOL_SIZE_POLICIES_HPP_INCLUDED
+
+
+
+/// The namespace threadpool contains a thread pool and related utility classes.
+namespace boost { namespace threadpool
+{
+
+  /*! \brief SizePolicyController which provides no functionality.
+  *
+  * \param Pool The pool's core type.
+  */ 
+  template<typename Pool>
+  struct empty_controller
+  {
+    empty_controller(typename Pool::size_policy_type&, shared_ptr<Pool>) {}
+  };
+
+
+  /*! \brief SizePolicyController which allows resizing.
+  *
+  * \param Pool The pool's core type.
+  */ 
+  template< typename Pool >
+  class resize_controller
+  {
+    typedef typename Pool::size_policy_type size_policy_type;
+    reference_wrapper<size_policy_type> m_policy;
+    shared_ptr<Pool> m_pool;                           //!< to make sure that the pool is alive (the policy pointer is valid) as long as the controller exists
+
+  public:
+    resize_controller(size_policy_type& policy, shared_ptr<Pool> pool)
+      : m_policy(policy)
+      , m_pool(pool)
+    {
+    }
+
+    bool resize(size_t worker_count)
+    {
+      return m_policy.get().resize(worker_count);
+    }
+  };
+
+
+  /*! \brief SizePolicy which preserves the thread count.
+  *
+  * \param Pool The pool's core type.
+  */ 
+  template<typename Pool>
+  class static_size
+  {
+    reference_wrapper<Pool volatile> m_pool;
+
+  public:
+    static void init(Pool& pool, size_t const worker_count)
+    {
+      pool.resize(worker_count);
+    }
+
+    static_size(Pool volatile & pool)
+      : m_pool(pool)
+    {}
+
+    bool resize(size_t const worker_count)
+    {
+      return m_pool.get().resize(worker_count);
+    }
+
+    void worker_died_unexpectedly(size_t const new_worker_count)
+    {
+      m_pool.get().resize(new_worker_count + 1);
+    }
+
+    // TODO this functions are not called yet
+    void task_scheduled() {}
+    void task_finished() {}
+  };
+
+} } // namespace boost::threadpool
+
+#endif // THREADPOOL_SIZE_POLICIES_HPP_INCLUDED

=== added file 'shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/task_adaptors.hpp'
--- shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/task_adaptors.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/include/threadpool/threadpool/task_adaptors.hpp	2007-11-21 00:01:14 +0000
@@ -0,0 +1,168 @@
+/*! \file
+* \brief Task adaptors.
+*
+* This file contains adaptors for task function objects.
+*
+* Copyright (c) 2005-2007 Philipp Henkel
+*
+* Use, modification, and distribution are  subject to the
+* Boost Software License, Version 1.0. (See accompanying  file
+* LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+*
+* http://threadpool.sourceforge.net
+*
+*/
+
+
+#ifndef THREADPOOL_TASK_ADAPTERS_HPP_INCLUDED
+#define THREADPOOL_TASK_ADAPTERS_HPP_INCLUDED
+
+
+#include <boost/smart_ptr.hpp>
+#include <boost/function.hpp>
+#include <boost/thread.hpp>
+
+
+namespace boost { namespace threadpool
+{
+
+  /*! \brief Standard task function object.
+  *
+  * This function object wraps a nullary function which returns void.
+  * The wrapped function is invoked by calling the operator ().
+  *
+  * \see boost function library
+  *
+  */ 
+  typedef function0<void> task_func;
+
+
+
+
+  /*! \brief Prioritized task function object. 
+  *
+  * This function object wraps a task_func object and binds a priority to it.
+  * prio_task_funcs can be compared using the operator < which realises a partial ordering.
+  * The wrapped task function is invoked by calling the operator ().
+  *
+  * \see prio_scheduler
+  *
+  */ 
+  class prio_task_func
+  {
+  private:
+    unsigned int m_priority;  //!< The priority of the task's function.
+    task_func m_function;     //!< The task's function.
+
+  public:
+    typedef void result_type; //!< Indicates the functor's result type.
+
+  public:
+    /*! Constructor.
+    * \param priority The priority of the task.
+    * \param function The task's function object.
+    */
+    prio_task_func(unsigned int const priority, task_func const & function)
+      : m_priority(priority)
+      , m_function(function)
+    {
+    }
+
+    /*! Executes the task function.
+    */
+    void operator() (void) const
+    {
+      if(m_function)
+      {
+        m_function();
+      }
+    }
+
+    /*! Comparison operator which realises a partial ordering based on priorities.
+    * \param rhs The object to compare with.
+    * \return true if the priority of *this is less than right hand side's priority, false otherwise.
+    */
+    bool operator< (const prio_task_func& rhs) const
+    {
+      return m_priority < rhs.m_priority; 
+    }
+
+  };  // prio_task_func
+
+
+
+ 
+
+
+
+
+  /*! \brief Looped task function object. 
+  *
+  * This function object wraps a boolean thread function object.
+  * The wrapped task function is invoked by calling the operator () and it is executed in regular 
+  * time intervals until false is returned. The interval length may be zero.
+  * Please note that a pool's thread is engaged as long as the task is looped.
+  *
+  */ 
+  class looped_task_func
+  {
+  private:
+    function0<bool> m_function;   //!< The task's function.
+    unsigned int m_break_s;              //!< Duration of breaks in seconds.
+    unsigned int m_break_ns;             //!< Duration of breaks in nano seconds.
+
+  public:
+    typedef void result_type; //!< Indicates the functor's result type.
+
+  public:
+    /*! Constructor.
+    * \param function The task's function object which is looped until false is returned.
+    * \param interval The minimum break time in milli seconds before the first execution of the task function and between the following ones.
+    */
+    looped_task_func(function0<bool> const & function, unsigned int const interval = 0)
+      : m_function(function)
+    {
+      m_break_s  = interval / 1000;
+      m_break_ns = (interval - m_break_s * 1000) * 1000 * 1000;
+    }
+
+    /*! Executes the task function.
+    */
+    void operator() (void) const
+    {
+      if(m_function)
+      {
+        if(m_break_s > 0 || m_break_ns > 0)
+        { // Sleep some time before first execution
+          xtime xt;
+          xtime_get(&xt, TIME_UTC);
+          xt.nsec += m_break_ns;
+          xt.sec += m_break_s;
+          thread::sleep(xt); 
+        }
+
+        while(m_function())
+        {
+          if(m_break_s > 0 || m_break_ns > 0)
+          {
+            xtime xt;
+            xtime_get(&xt, TIME_UTC);
+            xt.nsec += m_break_ns;
+            xt.sec += m_break_s;
+            thread::sleep(xt); 
+          }
+          else
+          {
+            thread::yield(); // Be fair to other threads
+          }
+        }
+      }
+    }
+
+  }; // looped_task_func
+
+
+} } // namespace boost::threadpool
+
+#endif // THREADPOOL_TASK_ADAPTERS_HPP_INCLUDED
+

=== removed directory 'shadow_robot/dataglove/dataglove_processing/launch'
=== removed file 'shadow_robot/dataglove/dataglove_processing/launch/usb_camera.launch'
--- shadow_robot/dataglove/dataglove_processing/launch/usb_camera.launch	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/launch/usb_camera.launch	1970-01-01 00:00:00 +0000
@@ -1,11 +0,0 @@
-<launch>
-  <node name="usb_cam" pkg="usb_cam" type="usb_cam_node" output="screen" >
-    <param name="video_device" value="/dev/video0" />
-    <param name="image_width" value="640" />
-    <param name="image_height" value="480" />
-    <param name="pixel_format" value="mjpeg" />
-    <param name="camera_frame_id" value="usb_cam" />
-    <param name="io_method" value="mmap"/>
-  </node>
-  <node name="optical_dataglove" pkg="optical_dataglove" type="optical_dataglove" output="screen" />
-</launch>

=== added file 'shadow_robot/dataglove/dataglove_processing/mainpage.dox'
--- shadow_robot/dataglove/dataglove_processing/mainpage.dox	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/mainpage.dox	2010-11-09 11:11:27 +0000
@@ -0,0 +1,26 @@
+/**
+\mainpage
+\htmlinclude manifest.html
+
+\b dataglove_processing is ... 
+
+<!-- 
+Provide an overview of your package.
+-->
+
+
+\section codeapi Code API
+
+<!--
+Provide links to specific auto-generated API documentation within your
+package that is of particular interest to a reader. Doxygen will
+document pretty much every part of your code, so do your best here to
+point the reader to the actual API.
+
+If your codebase is fairly large or has different sets of APIs, you
+should use the doxygen 'group' tag to keep these APIs together. For
+example, the roscpp documentation has 'libros' group.
+-->
+
+
+*/

=== removed file 'shadow_robot/dataglove/dataglove_processing/mainpage.dox'
--- shadow_robot/dataglove/dataglove_processing/mainpage.dox	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/mainpage.dox	1970-01-01 00:00:00 +0000
@@ -1,43 +0,0 @@
-/**
-\mainpage
-\htmlinclude manifest.html
-
-\b optical_dataglove is ... 
-
-<!-- 
-Provide an overview of your package.
--->
-
-\section dependencies installing dependencies
-\subsection usbcam usb_cam ros driver - Bosch
-The optical dataglove package depends on the usb_cam driver from Bosch. 
-To install it, run the following commands:
-\verbatim 
-cd ~/ros/stacks
-svn co https://bosch-ros-pkg.svn.sourceforge.net/svnroot/bosch-ros-pkg
-cd ~/ros/stacks/bosch-ros-pkg/trunk/bosch_drivers/usb_cam
-rosdep install usb_cam
-rosmake --rosdep-install image_view usb_cam
-
-\endverbatim
-
-You can test it has been installed by running:
-\verbatim
-roslaunch optical_dataglove test_usb_cam.launch
-\endverbatim
-
-\section codeapi Code API
-
-<!--
-Provide links to specific auto-generated API documentation within your
-package that is of particular interest to a reader. Doxygen will
-document pretty much every part of your code, so do your best here to
-point the reader to the actual API.
-
-If your codebase is fairly large or has different sets of APIs, you
-should use the doxygen 'group' tag to keep these APIs together. For
-example, the roscpp documentation has 'libros' group.
--->
-
-
-*/

=== added file 'shadow_robot/dataglove/dataglove_processing/manifest.xml'
--- shadow_robot/dataglove/dataglove_processing/manifest.xml	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/manifest.xml	2010-11-09 16:29:40 +0000
@@ -0,0 +1,16 @@
+<package>
+  <description brief="dataglove_processing">
+
+     dataglove_processing
+
+  </description>
+  <author>Ugo Cupcic</author>
+  <license>BSD</license>
+  <review status="unreviewed" notes=""/>
+  <url>http://ros.org/wiki/dataglove_processing</url>
+  <depend package="roscpp"/>
+  <depend package="sr_hand"/>
+  <depend package="math_utils"/>
+</package>
+
+

=== removed file 'shadow_robot/dataglove/dataglove_processing/manifest.xml'
--- shadow_robot/dataglove/dataglove_processing/manifest.xml	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/manifest.xml	1970-01-01 00:00:00 +0000
@@ -1,23 +0,0 @@
-<package>
-  <description brief="optical_dataglove">
-
-     optical_dataglove
-
-  </description>
-  <author>Ugo Cupcic</author>
-  <license>BSD</license>
-  <review status="unreviewed" notes=""/>
-  <url>http://ros.org/wiki/optical_dataglove</url>
-  <depend package="roscpp"/>
-  <depend package="rospy"/>
-  <depend package="std_msgs"/>
-  <depend package="sensor_msgs"/>
-  <depend package="cv_bridge"/>
-  <depend package="opencv2"/>
-  <depend package="usb_cam"/>
-  <depend package="image_transport"/>
-
-</package>
-
-
-

=== added directory 'shadow_robot/dataglove/dataglove_processing/src'
=== removed directory 'shadow_robot/dataglove/dataglove_processing/src'
=== removed file 'shadow_robot/dataglove/dataglove_processing/src/database_mapping.cpp'
--- shadow_robot/dataglove/dataglove_processing/src/database_mapping.cpp	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/src/database_mapping.cpp	1970-01-01 00:00:00 +0000
@@ -1,62 +0,0 @@
-#include  "optical_dataglove/database_mapping.h"
-
-namespace opticaldataglove{
-
-DatabaseMapping::DatabaseMapping(boost::shared_ptr<DataAnalyser> data_analyser): PositionMapper()
-{
-    this->dataAnalyser=data_analyser;
-    initializeHandPositions();
-}
-
-DatabaseMapping::~DatabaseMapping()
-{
-
-}
-
-std::map<std::string, JointData> DatabaseMapping::getHandPositions()
-{
-    return handPositions;
-}
-
-void DatabaseMapping::initializeHandPositions()
-{
-    this->handPositions["THJ1"] = JointData();
-    this->handPositions["THJ1"].position =0.0;
-    this->handPositions["THJ2"] = JointData();
-    this->handPositions["THJ2"].position = 0.0;
-    this->handPositions["THJ3"] = JointData();
-    this->handPositions["THJ3"].position = 0.0;
-    this->handPositions["THJ4"] = JointData();
-    this->handPositions["THJ4"].position = 0.0;
-    this->handPositions["THJ5"] = JointData();
-    this->handPositions["THJ5"].position = 0.0;
-    this->handPositions["FFJ0"] = JointData();
-    this->handPositions["FFJ0"].position = 0.0;
-    this->handPositions["FFJ3"] = JointData();
-    this->handPositions["FFJ3"].position = 0.0;
-    this->handPositions["FFJ4"] = JointData();
-    this->handPositions["FFJ4"].position = 0.0;
-    this->handPositions["MFJ0"] = JointData();
-    this->handPositions["MFJ0"].position = 0.0;
-    this->handPositions["MFJ3"] = JointData();
-    this->handPositions["MFJ3"].position = 0.0;
-    this->handPositions["MFJ4"] = JointData();
-    this->handPositions["MFJ4"].position = 0.0;
-    this->handPositions["RFJ0"] = JointData();
-    this->handPositions["RFJ0"].position = 0.0;
-    this->handPositions["RFJ3"] = JointData();
-    this->handPositions["RFJ3"].position = 0.0;
-    this->handPositions["RFJ4"] = JointData();
-    this->handPositions["RFJ4"].position = 0.0;
-    this->handPositions["LFJ0"] = JointData();
-    this->handPositions["LFJ0"].position = 0.0;
-    this->handPositions["LFJ3"] = JointData();
-    this->handPositions["LFJ3"].position = 0.0;
-    this->handPositions["LFJ4"] = JointData();
-    this->handPositions["LFJ4"].position = 0.0;
-    this->handPositions["LFJ5"] = JointData();
-    this->handPositions["LFJ5"].position = 0.0;
- 
-}
-
-}

=== added file 'shadow_robot/dataglove/dataglove_processing/src/dataglove_processing.cpp'
--- shadow_robot/dataglove/dataglove_processing/src/dataglove_processing.cpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/src/dataglove_processing.cpp	2010-11-16 17:55:15 +0000
@@ -0,0 +1,185 @@
+/**
+ * @file dataglove_processing.cpp
+ * @author Ugo Cupcic <ugo@shadowrobot.com>, Contact <contact@shadowrobot.com>
+ * @date 9 Nov 2010
+ *
+ * @brief 
+ *
+ *
+ */
+
+#include "dataglove_processing.hpp"
+
+namespace dataglove
+{
+const unsigned int DatagloveProcessing::total_number_of_particles = 200;
+const float DatagloveProcessing::average_weight = 1.0f / ((float)DatagloveProcessing::total_number_of_particles);
+const float DatagloveProcessing::n_min = (DatagloveProcessing::total_number_of_particles * 0.7f);
+
+DatagloveProcessing::DatagloveProcessing() :
+    nh_tilde("~"), update_rate(0.0)
+{
+    //detect the optimal number of threads to use in the thread pool
+    int nb_possible_threads = boost::thread::hardware_concurrency();
+    ROS_INFO("will use %d threads", nb_possible_threads);
+    threadpool = boost::threadpool::pool(nb_possible_threads);
+
+    math_utils = boost::shared_ptr<math_utils::MathUtils>(new math_utils::MathUtils());
+    particle_cloud = boost::shared_ptr<boost::ptr_vector<ParticleSrHand> >(new boost::ptr_vector<ParticleSrHand>());
+    particle_cloud_tmp = boost::shared_ptr<boost::ptr_vector<ParticleSrHand> >(new boost::ptr_vector<ParticleSrHand>());
+
+    particle_cloud->reserve(total_number_of_particles);
+    particle_cloud_tmp->reserve(total_number_of_particles);
+
+    n_eff_standard = 0.0f;
+    for( unsigned int particle_index = 0; particle_index < total_number_of_particles; ++particle_index )
+    {
+        particle_cloud->push_back(new ParticleSrHand(total_number_of_particles));
+        n_eff_standard += (average_weight * average_weight);
+    }
+
+    n_eff_standard = 1.0f / n_eff_standard;
+
+    mutex_sum_weights = boost::shared_ptr<boost::mutex>(new boost::mutex());
+    sum_weights = boost::shared_ptr<float>(new float(0.0f));
+    sum_squared_weights = boost::shared_ptr<float>(new float(0.0f));
+
+    // set update frequency
+    double update_freq;
+    nh_tilde.param("update_frequency", update_freq, 20.0);
+    update_rate = ros::Rate(update_freq);
+
+    n_eff = n_eff_standard;
+}
+
+DatagloveProcessing::~DatagloveProcessing()
+{
+
+}
+
+int DatagloveProcessing::update()
+{
+    int result = update_cycle();
+
+    ros::spinOnce();
+    update_rate.sleep();
+
+    return result;
+}
+
+int DatagloveProcessing::update_cycle()
+{
+    part_it_t particle;
+
+    /*
+     * n_eff measures the degenerecence of the cloud.
+     * n_eff is computed during the update process
+     * n_eff = 1/(sum(weights^2))
+     */
+    n_eff = 0;
+    for( particle = particle_cloud->begin(); particle != particle_cloud->end(); ++particle )
+    {
+        last_measure_mutex.lock();
+        particle->set_last_measure(last_measure);
+        last_measure_mutex.unlock();
+
+        threadpool.schedule(boost::bind(&ParticleSrHand::update, &*particle, sum_weights.get(), mutex_sum_weights.get()));
+    }
+    //wait until all the tasks are finished
+    threadpool.wait();
+
+    //Normalise the weights + set square weights at the same time.
+    for( particle = particle_cloud->begin(); particle != particle_cloud->end(); ++particle )
+    {
+        *sum_squared_weights += particle->set_weight(particle->get_weight() / (*sum_weights));
+    }
+
+    //recompute the n_eff (used to check if resampling is necessary or not)
+    n_eff = 1.0f / *sum_squared_weights;
+
+    //resample if necessary
+    return resampling();
+}
+
+int DatagloveProcessing::resampling()
+{
+    /*
+     * don't resample if not enough convergence
+     * n_eff is computed during the update process
+     * n_eff = 1/(sum(weights^2))
+     */
+    if( n_eff > n_min )
+        return 0;
+
+    //reorder the vector by growing weights:
+    particle_cloud->sort(compare_particle_weights);
+
+    /*
+     * The total fitness of the population has been normalized to 1.
+     */
+    float start = math_utils->maut_random(0.0f, average_weight);
+
+    float fitness = 0.0f;
+    for( float i = 0.0f; i < (float)total_number_of_particles; i = i + 1.0f )
+    {
+        fitness = start + i * average_weight;
+
+        //run a roulette wheel selection for each value of fitness selected
+        particle_cloud_tmp->push_back(roulette_wheel_selection(fitness));
+    }
+    particle_cloud->clear();
+
+    /*
+     * particle_cloud will now point to particle_cloud_tmp and particle_cloud_tmp is
+     * then reset.
+     */
+    particle_cloud = particle_cloud_tmp;
+    particle_cloud_tmp = boost::shared_ptr<boost::ptr_vector<ParticleSrHand> >(new boost::ptr_vector<ParticleSrHand>());
+
+    n_eff = n_eff_standard;
+    return 1;
+}
+
+ParticleSrHand* DatagloveProcessing::roulette_wheel_selection( float fitness )
+{
+    float tmp = 0.0f;
+    float weight = 0.0f;
+    part_auto_ptr_t part_tmp;
+
+    for( part_it_t particle = particle_cloud->begin(); particle != particle_cloud->end(); ++particle )
+    {
+        weight = particle->get_weight();
+        if( tmp < fitness && tmp + weight > fitness )
+        {
+            return new ParticleSrHand(particle, true, average_weight);
+        }
+        tmp += weight;
+    }
+    return NULL;
+}
+
+std::vector<float> DatagloveProcessing::get_weights_vector()
+{
+    std::vector<float> weights;
+    part_it_t particle;
+    for( particle = particle_cloud->begin(); particle != particle_cloud->end(); ++particle )
+    {
+        weights.push_back(particle->get_weight());
+    }
+    return weights;
+}
+
+std::vector<std::vector<float> > DatagloveProcessing::get_particle_positions_vector()
+{
+    std::vector<std::vector<float> > all_part_positions;
+    part_it_t particle;
+    for( particle = particle_cloud->begin(); particle != particle_cloud->end(); ++particle )
+    {
+        std::vector<float> part_pos;
+        part_pos = particle->get_positions();
+        all_part_positions.push_back(part_pos);
+    }
+    return all_part_positions;
+}
+
+}//end namespace

=== added file 'shadow_robot/dataglove/dataglove_processing/src/dataglove_processing_node.cpp'
--- shadow_robot/dataglove/dataglove_processing/src/dataglove_processing_node.cpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/src/dataglove_processing_node.cpp	2010-11-09 13:12:17 +0000
@@ -0,0 +1,36 @@
+/**
+ * @file dataglove_processing_node.cpp
+ * @author Ugo Cupcic <ugo@shadowrobot.com>, Contact <contact@shadowrobot.com>
+ * @date 9 Nov 2010
+ *
+ * @brief 
+ *
+ *
+ */
+
+#include "dataglove_processing.hpp"
+
+#include <ros/ros.h>
+
+#include <boost/thread.hpp>
+#include <boost/smart_ptr.hpp>
+
+using namespace dataglove;
+
+void update( boost::shared_ptr<DatagloveProcessing> dataglove_processing )
+{
+    while( ros::ok() )
+        dataglove_processing->update();
+}
+
+int main( int argc, char** argv )
+{
+    ros::init(argc, argv, "dataglove_processing");
+    ros::NodeHandle n;
+
+    boost::shared_ptr<DatagloveProcessing> dataglove_processing(new DatagloveProcessing());
+
+    boost::thread thread_update(boost::bind(&update, dataglove_processing));
+    thread_update.join();
+    return 0;
+}

=== added file 'shadow_robot/dataglove/dataglove_processing/src/measure.cpp'
--- shadow_robot/dataglove/dataglove_processing/src/measure.cpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/src/measure.cpp	2010-11-09 12:20:16 +0000
@@ -0,0 +1,25 @@
+/**
+ * @file measure.cpp
+ * @author Ugo Cupcic <ugo@shadowrobot.com>, Contact <contact@shadowrobot.com>
+ * @date 9 Nov 2010
+ *
+ * @brief 
+ *
+ *
+ */
+
+#include "measure.hpp"
+
+namespace dataglove
+{
+Measure::Measure()
+{
+
+}
+
+Measure::~Measure()
+{
+
+}
+
+}

=== removed file 'shadow_robot/dataglove/dataglove_processing/src/message_publisher.cpp'
--- shadow_robot/dataglove/dataglove_processing/src/message_publisher.cpp	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/src/message_publisher.cpp	1970-01-01 00:00:00 +0000
@@ -1,55 +0,0 @@
-#include "optical_dataglove/message_publisher.h"
-
-namespace opticaldataglove
-{
-
-MessagePublisher::MessagePublisher(boost::shared_ptr<PositionMapper> position_mapper): publishedTopic("joint_state"), node("~"), positionMapper(position_mapper), isPublishing(true)
-{
-     service_start = node.advertiseService("start", &MessagePublisher::start, this);
-     service_stop = node.advertiseService("stop", &MessagePublisher::stop, this);
-    publisher = node.advertise<sensor_msgs::JointState>("joint_state",2); 
-    ROS_INFO("Ready to start");
-}
-
-MessagePublisher::~MessagePublisher()
-{
-
-}
-
-bool MessagePublisher::start(opticaldataglove::Start::Request &req, opticaldataglove::Start::Response &res)
-{
-    ROS_INFO("Starting publisher");
-    isPublishing = true;
-    res.state = true;
-    return true;
-}
-
-bool MessagePublisher::stop(opticaldataglove::Stop::Request &req, opticaldataglove::Stop::Response &res)
-{
-    ROS_INFO("Stoping publisher");
-    isPublishing = false;
-    res.state = false;
-    return true;
-}
-
-void MessagePublisher::publish()
-{
-   if (isPublishing){ 
-        std::map<std::string, JointData> map = this->positionMapper->getHandPositions();
-        sensor_msgs::JointState joint_state;
-        joint_state.header.stamp = ros::Time::now();
-
-        for(std::map<std::string, JointData>::const_iterator it = map.begin(); it != map.end(); it++)
-        {
-            JointData value = it->second;
-            joint_state.name.push_back(it->first);
-            joint_state.position.push_back(value.position);
-            joint_state.velocity.push_back(0.0);
-            joint_state.effort.push_back(0.0);
-        }
-
-        this->publisher.publish(joint_state);
-    }
-}
-
-}

=== removed file 'shadow_robot/dataglove/dataglove_processing/src/optical_dataglove.cpp'
--- shadow_robot/dataglove/dataglove_processing/src/optical_dataglove.cpp	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/src/optical_dataglove.cpp	1970-01-01 00:00:00 +0000
@@ -1,60 +0,0 @@
-/**
- * @file   optical_dataglove.cpp
- * @author Ugo Cupcic <ugo@shadowrobot.com>
- * @date   Wed Jul  7 18:07:42 2010
- * 
- * @brief  The Optical Dataglove class
- * 
- * 
- */
-
-#include "optical_dataglove/optical_dataglove.h"
-
-namespace optical_dataglove
-{
-  OpticalDataglove::OpticalDataglove (ros::NodeHandle & nh):nh_ (nh), it_ (nh_)
-  {
-    // Advertise image messages to a topic
-    image_pub_ = it_.advertise ("/demo/output_image", 1);
-    // Listen for image messages on a topic and setup callback
-    image_sub_ = it_.subscribe ("/usb_cam/image_raw", 1, &OpticalDataglove::imageCallback, this);
-    // Open HighGUI Window
-    cv::namedWindow ("hsv", 1);
-  }
-
-  void OpticalDataglove::imageCallback (const sensor_msgs::ImageConstPtr & msg_ptr)
-  {
-    // Convert ROS Imput Image Message to IplImage
-    try
-      {
-	cv_input_ = bridge_.imgMsgToCv (msg_ptr, "bgr8");
-      }
-    catch (sensor_msgs::CvBridgeException error)
-      {
-	ROS_ERROR ("CvBridge Input Error");
-      }
-
-    // Convert IplImage to cv::Mat
-    img_in_ = cv::Mat (cv_input_).clone ();
-    // Convert Input image from BGR to HSV
-    cv::cvtColor (img_in_, img_hsv_, CV_BGR2HSV);
-
-    // Display HSV Image in HighGUI window
-    cv::imshow ("hsv", img_hsv_);
-
-    // Needed to  keep the HighGUI window open
-    cv::waitKey (3);
-
-    // Convert cv::Mat to IplImage
-    cv_output_ = img_hsv_;
-    // Convert IplImage to ROS Output Image Message and Publish
-    try
-      {
-	image_pub_.publish (bridge_.cvToImgMsg (&cv_output_, "bgr8"));
-      }
-    catch (sensor_msgs::CvBridgeException error)
-      {
-	ROS_ERROR ("CvBridge Output error");
-      }
-  }
-}; //end namespace

=== removed file 'shadow_robot/dataglove/dataglove_processing/src/optical_dataglove_node.cpp'
--- shadow_robot/dataglove/dataglove_processing/src/optical_dataglove_node.cpp	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/src/optical_dataglove_node.cpp	1970-01-01 00:00:00 +0000
@@ -1,47 +0,0 @@
-/**
- * @file   optical_dataglove_node.cpp
- * @author Ugo Cupcic <ugo@shadowrobot.com>
- * @date   Wed Jul  7 18:02:38 2010
- * 
- * @brief  Contains the main for the optical dataglove. Start a ROS node.
- * 
- * 
- */
-
-
-#include <boost/smart_ptr.hpp>
-#include "optical_dataglove/message_publisher.h"
-#include "optical_dataglove/data_analyser.h"
-#include "optical_dataglove/two_dimensions.h"
-#include "optical_dataglove/position_mapper.h"
-#include "optical_dataglove/reverse_kinematics.h"
-#include "optical_dataglove/optical_dataglove.h"
-
-using namespace opticaldataglove;
-
-int main (int argc, char **argv)
-{
-  // Initialize ROS Node
-  ros::init (argc, argv, "optical_dataglove");
-  // Start node and create a Node Handle
-  ros::NodeHandle nh;
-  // Instantiate 
-  //boost::shared_ptr<OpticalDataglove> optical_dataglove (new OpticalDataglove(nh));
-  boost::shared_ptr<DataAnalyser> data (new TwoDimensionsAnalyser());
-  boost::shared_ptr<PositionMapper> pos (new ReverseKinematics(data));
-  boost::shared_ptr<MessagePublisher> mes (new MessagePublisher(pos));
-  //mes->start();
-  // Spin ...
-  ros::Rate loop_rate(5);
-  
-  while(ros::ok()){
-    //ROS_INFO("ros::ok()");
-    mes->publish();
-    ros::spinOnce();
-    loop_rate.sleep();
-  }
-
-  ros::spin ();
-  // ... until done
-  return 0;
-}

=== removed directory 'shadow_robot/dataglove/dataglove_processing/src/opticaldataglove'
=== removed file 'shadow_robot/dataglove/dataglove_processing/src/opticaldataglove/__init__.py'
=== removed directory 'shadow_robot/dataglove/dataglove_processing/src/opticaldataglove/srv'
=== removed file 'shadow_robot/dataglove/dataglove_processing/src/opticaldataglove/srv/_Start.py'
--- shadow_robot/dataglove/dataglove_processing/src/opticaldataglove/srv/_Start.py	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/src/opticaldataglove/srv/_Start.py	1970-01-01 00:00:00 +0000
@@ -1,199 +0,0 @@
-"""autogenerated by genmsg_py from StartRequest.msg. Do not edit."""
-import roslib.message
-import struct
-
-
-class StartRequest(roslib.message.Message):
-  _md5sum = "d41d8cd98f00b204e9800998ecf8427e"
-  _type = "opticaldataglove/StartRequest"
-  _has_header = False #flag to mark the presence of a Header object
-  _full_text = """
-"""
-  __slots__ = []
-  _slot_types = []
-
-  def __init__(self, *args, **kwds):
-    """
-    Constructor. Any message fields that are implicitly/explicitly
-    set to None will be assigned a default value. The recommend
-    use is keyword arguments as this is more robust to future message
-    changes.  You cannot mix in-order arguments and keyword arguments.
-    
-    The available fields are:
-       
-    
-    @param args: complete set of field values, in .msg order
-    @param kwds: use keyword arguments corresponding to message field names
-    to set specific fields. 
-    """
-    if args or kwds:
-      super(StartRequest, self).__init__(*args, **kwds)
-
-  def _get_types(self):
-    """
-    internal API method
-    """
-    return self._slot_types
-
-  def serialize(self, buff):
-    """
-    serialize message into buffer
-    @param buff: buffer
-    @type  buff: StringIO
-    """
-    try:
-      pass
-    except struct.error, se: self._check_types(se)
-    except TypeError, te: self._check_types(te)
-
-  def deserialize(self, str):
-    """
-    unpack serialized message in str into this message instance
-    @param str: byte array of serialized message
-    @type  str: str
-    """
-    try:
-      end = 0
-      return self
-    except struct.error, e:
-      raise roslib.message.DeserializationError(e) #most likely buffer underfill
-
-
-  def serialize_numpy(self, buff, numpy):
-    """
-    serialize message with numpy array types into buffer
-    @param buff: buffer
-    @type  buff: StringIO
-    @param numpy: numpy python module
-    @type  numpy module
-    """
-    try:
-      pass
-    except struct.error, se: self._check_types(se)
-    except TypeError, te: self._check_types(te)
-
-  def deserialize_numpy(self, str, numpy):
-    """
-    unpack serialized message in str into this message instance using numpy for array types
-    @param str: byte array of serialized message
-    @type  str: str
-    @param numpy: numpy python module
-    @type  numpy: module
-    """
-    try:
-      end = 0
-      return self
-    except struct.error, e:
-      raise roslib.message.DeserializationError(e) #most likely buffer underfill
-
-_struct_I = roslib.message.struct_I
-"""autogenerated by genmsg_py from StartResponse.msg. Do not edit."""
-import roslib.message
-import struct
-
-
-class StartResponse(roslib.message.Message):
-  _md5sum = "001fde3cab9e313a150416ff09c08ee4"
-  _type = "opticaldataglove/StartResponse"
-  _has_header = False #flag to mark the presence of a Header object
-  _full_text = """bool state
-
-
-"""
-  __slots__ = ['state']
-  _slot_types = ['bool']
-
-  def __init__(self, *args, **kwds):
-    """
-    Constructor. Any message fields that are implicitly/explicitly
-    set to None will be assigned a default value. The recommend
-    use is keyword arguments as this is more robust to future message
-    changes.  You cannot mix in-order arguments and keyword arguments.
-    
-    The available fields are:
-       state
-    
-    @param args: complete set of field values, in .msg order
-    @param kwds: use keyword arguments corresponding to message field names
-    to set specific fields. 
-    """
-    if args or kwds:
-      super(StartResponse, self).__init__(*args, **kwds)
-      #message fields cannot be None, assign default values for those that are
-      if self.state is None:
-        self.state = False
-    else:
-      self.state = False
-
-  def _get_types(self):
-    """
-    internal API method
-    """
-    return self._slot_types
-
-  def serialize(self, buff):
-    """
-    serialize message into buffer
-    @param buff: buffer
-    @type  buff: StringIO
-    """
-    try:
-      buff.write(_struct_B.pack(self.state))
-    except struct.error, se: self._check_types(se)
-    except TypeError, te: self._check_types(te)
-
-  def deserialize(self, str):
-    """
-    unpack serialized message in str into this message instance
-    @param str: byte array of serialized message
-    @type  str: str
-    """
-    try:
-      end = 0
-      start = end
-      end += 1
-      (self.state,) = _struct_B.unpack(str[start:end])
-      self.state = bool(self.state)
-      return self
-    except struct.error, e:
-      raise roslib.message.DeserializationError(e) #most likely buffer underfill
-
-
-  def serialize_numpy(self, buff, numpy):
-    """
-    serialize message with numpy array types into buffer
-    @param buff: buffer
-    @type  buff: StringIO
-    @param numpy: numpy python module
-    @type  numpy module
-    """
-    try:
-      buff.write(_struct_B.pack(self.state))
-    except struct.error, se: self._check_types(se)
-    except TypeError, te: self._check_types(te)
-
-  def deserialize_numpy(self, str, numpy):
-    """
-    unpack serialized message in str into this message instance using numpy for array types
-    @param str: byte array of serialized message
-    @type  str: str
-    @param numpy: numpy python module
-    @type  numpy: module
-    """
-    try:
-      end = 0
-      start = end
-      end += 1
-      (self.state,) = _struct_B.unpack(str[start:end])
-      self.state = bool(self.state)
-      return self
-    except struct.error, e:
-      raise roslib.message.DeserializationError(e) #most likely buffer underfill
-
-_struct_I = roslib.message.struct_I
-_struct_B = struct.Struct("<B")
-class Start(roslib.message.ServiceDefinition):
-  _type          = 'opticaldataglove/Start'
-  _md5sum = '001fde3cab9e313a150416ff09c08ee4'
-  _request_class  = StartRequest
-  _response_class = StartResponse

=== removed file 'shadow_robot/dataglove/dataglove_processing/src/opticaldataglove/srv/_Stop.py'
--- shadow_robot/dataglove/dataglove_processing/src/opticaldataglove/srv/_Stop.py	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/src/opticaldataglove/srv/_Stop.py	1970-01-01 00:00:00 +0000
@@ -1,199 +0,0 @@
-"""autogenerated by genmsg_py from StopRequest.msg. Do not edit."""
-import roslib.message
-import struct
-
-
-class StopRequest(roslib.message.Message):
-  _md5sum = "d41d8cd98f00b204e9800998ecf8427e"
-  _type = "opticaldataglove/StopRequest"
-  _has_header = False #flag to mark the presence of a Header object
-  _full_text = """
-"""
-  __slots__ = []
-  _slot_types = []
-
-  def __init__(self, *args, **kwds):
-    """
-    Constructor. Any message fields that are implicitly/explicitly
-    set to None will be assigned a default value. The recommend
-    use is keyword arguments as this is more robust to future message
-    changes.  You cannot mix in-order arguments and keyword arguments.
-    
-    The available fields are:
-       
-    
-    @param args: complete set of field values, in .msg order
-    @param kwds: use keyword arguments corresponding to message field names
-    to set specific fields. 
-    """
-    if args or kwds:
-      super(StopRequest, self).__init__(*args, **kwds)
-
-  def _get_types(self):
-    """
-    internal API method
-    """
-    return self._slot_types
-
-  def serialize(self, buff):
-    """
-    serialize message into buffer
-    @param buff: buffer
-    @type  buff: StringIO
-    """
-    try:
-      pass
-    except struct.error, se: self._check_types(se)
-    except TypeError, te: self._check_types(te)
-
-  def deserialize(self, str):
-    """
-    unpack serialized message in str into this message instance
-    @param str: byte array of serialized message
-    @type  str: str
-    """
-    try:
-      end = 0
-      return self
-    except struct.error, e:
-      raise roslib.message.DeserializationError(e) #most likely buffer underfill
-
-
-  def serialize_numpy(self, buff, numpy):
-    """
-    serialize message with numpy array types into buffer
-    @param buff: buffer
-    @type  buff: StringIO
-    @param numpy: numpy python module
-    @type  numpy module
-    """
-    try:
-      pass
-    except struct.error, se: self._check_types(se)
-    except TypeError, te: self._check_types(te)
-
-  def deserialize_numpy(self, str, numpy):
-    """
-    unpack serialized message in str into this message instance using numpy for array types
-    @param str: byte array of serialized message
-    @type  str: str
-    @param numpy: numpy python module
-    @type  numpy: module
-    """
-    try:
-      end = 0
-      return self
-    except struct.error, e:
-      raise roslib.message.DeserializationError(e) #most likely buffer underfill
-
-_struct_I = roslib.message.struct_I
-"""autogenerated by genmsg_py from StopResponse.msg. Do not edit."""
-import roslib.message
-import struct
-
-
-class StopResponse(roslib.message.Message):
-  _md5sum = "001fde3cab9e313a150416ff09c08ee4"
-  _type = "opticaldataglove/StopResponse"
-  _has_header = False #flag to mark the presence of a Header object
-  _full_text = """bool state
-
-
-"""
-  __slots__ = ['state']
-  _slot_types = ['bool']
-
-  def __init__(self, *args, **kwds):
-    """
-    Constructor. Any message fields that are implicitly/explicitly
-    set to None will be assigned a default value. The recommend
-    use is keyword arguments as this is more robust to future message
-    changes.  You cannot mix in-order arguments and keyword arguments.
-    
-    The available fields are:
-       state
-    
-    @param args: complete set of field values, in .msg order
-    @param kwds: use keyword arguments corresponding to message field names
-    to set specific fields. 
-    """
-    if args or kwds:
-      super(StopResponse, self).__init__(*args, **kwds)
-      #message fields cannot be None, assign default values for those that are
-      if self.state is None:
-        self.state = False
-    else:
-      self.state = False
-
-  def _get_types(self):
-    """
-    internal API method
-    """
-    return self._slot_types
-
-  def serialize(self, buff):
-    """
-    serialize message into buffer
-    @param buff: buffer
-    @type  buff: StringIO
-    """
-    try:
-      buff.write(_struct_B.pack(self.state))
-    except struct.error, se: self._check_types(se)
-    except TypeError, te: self._check_types(te)
-
-  def deserialize(self, str):
-    """
-    unpack serialized message in str into this message instance
-    @param str: byte array of serialized message
-    @type  str: str
-    """
-    try:
-      end = 0
-      start = end
-      end += 1
-      (self.state,) = _struct_B.unpack(str[start:end])
-      self.state = bool(self.state)
-      return self
-    except struct.error, e:
-      raise roslib.message.DeserializationError(e) #most likely buffer underfill
-
-
-  def serialize_numpy(self, buff, numpy):
-    """
-    serialize message with numpy array types into buffer
-    @param buff: buffer
-    @type  buff: StringIO
-    @param numpy: numpy python module
-    @type  numpy module
-    """
-    try:
-      buff.write(_struct_B.pack(self.state))
-    except struct.error, se: self._check_types(se)
-    except TypeError, te: self._check_types(te)
-
-  def deserialize_numpy(self, str, numpy):
-    """
-    unpack serialized message in str into this message instance using numpy for array types
-    @param str: byte array of serialized message
-    @type  str: str
-    @param numpy: numpy python module
-    @type  numpy: module
-    """
-    try:
-      end = 0
-      start = end
-      end += 1
-      (self.state,) = _struct_B.unpack(str[start:end])
-      self.state = bool(self.state)
-      return self
-    except struct.error, e:
-      raise roslib.message.DeserializationError(e) #most likely buffer underfill
-
-_struct_I = roslib.message.struct_I
-_struct_B = struct.Struct("<B")
-class Stop(roslib.message.ServiceDefinition):
-  _type          = 'opticaldataglove/Stop'
-  _md5sum = '001fde3cab9e313a150416ff09c08ee4'
-  _request_class  = StopRequest
-  _response_class = StopResponse

=== removed file 'shadow_robot/dataglove/dataglove_processing/src/opticaldataglove/srv/__init__.py'
--- shadow_robot/dataglove/dataglove_processing/src/opticaldataglove/srv/__init__.py	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/src/opticaldataglove/srv/__init__.py	1970-01-01 00:00:00 +0000
@@ -1,2 +0,0 @@
-from _Start import *
-from _Stop import *

=== added file 'shadow_robot/dataglove/dataglove_processing/src/particle.cpp'
--- shadow_robot/dataglove/dataglove_processing/src/particle.cpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/src/particle.cpp	2010-11-16 13:59:18 +0000
@@ -0,0 +1,65 @@
+/**
+ * @file particle.cpp
+ * @author Ugo Cupcic <ugo@shadowrobot.com>, Contact <contact@shadowrobot.com>
+ * @date 9 Nov 2010
+ *
+ * @brief 
+ *
+ *
+ */
+
+#include "particle.hpp"
+#include <ros/ros.h>
+
+namespace dataglove
+{
+Particle::Particle()
+{
+    init_weight(1);
+}
+
+Particle::Particle( int population_size )
+{
+    init_weight(population_size);
+}
+
+Particle::Particle( boost::ptr_vector<Particle>::iterator particle, bool reset_weight, float average_weight )
+{
+    if( reset_weight )
+        weight = average_weight;
+    else
+        weight = particle->weight;
+
+    squared_weight = weight * weight;
+}
+
+Particle::~Particle()
+{
+
+}
+
+void Particle::init_weight( int population_size )
+{
+    weight = 1.0f / ((float)population_size);
+    squared_weight = weight * weight;
+}
+
+float Particle::get_weight() const
+{
+    return weight;
+}
+
+float Particle::set_weight( float new_weight )
+{
+    weight = new_weight;
+    squared_weight = weight * weight;
+
+    return squared_weight;
+}
+
+void Particle::set_last_measure( boost::shared_ptr<Measure> last_measure )
+{
+    last_measure = last_measure;
+}
+
+}//end namespace

=== added file 'shadow_robot/dataglove/dataglove_processing/src/particle_sr_hand.cpp'
--- shadow_robot/dataglove/dataglove_processing/src/particle_sr_hand.cpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/src/particle_sr_hand.cpp	2010-11-16 13:54:24 +0000
@@ -0,0 +1,95 @@
+/**
+ * @file particle_sr_hand.cpp
+ * @author Ugo Cupcic <ugo@shadowrobot.com>, Contact <contact@shadowrobot.com>
+ * @date 9 Nov 2010
+ *
+ * @brief 
+ *
+ *
+ */
+
+#include "particle_sr_hand.hpp"
+
+using namespace shadowrobot;
+
+namespace dataglove
+{
+ParticleSrHand::ParticleSrHand() :
+    VirtualShadowhandLibrary(), Particle()
+{
+    math_utils = boost::shared_ptr<math_utils::MathUtils>(new math_utils::MathUtils());
+
+    init_model();
+}
+
+ParticleSrHand::ParticleSrHand( int population_size ) :
+    VirtualShadowhandLibrary(), Particle(population_size)
+{
+    math_utils = boost::shared_ptr<math_utils::MathUtils>(new math_utils::MathUtils());
+
+    init_model();
+}
+
+ParticleSrHand::ParticleSrHand( boost::ptr_vector<ParticleSrHand>::iterator particle, bool reset_weight, float average_weight ) :
+    Particle(particle, reset_weight, average_weight)
+{
+    math_utils = boost::shared_ptr<math_utils::MathUtils>(new math_utils::MathUtils());
+    joints_map_mutex.lock();
+    particle->joints_map_mutex.lock();
+    joints_map.insert(particle->joints_map.begin(), particle->joints_map.end());
+    particle->joints_map_mutex.unlock();
+    joints_map_mutex.unlock();
+}
+
+ParticleSrHand::~ParticleSrHand()
+{
+
+}
+
+void ParticleSrHand::init_model()
+{
+    JointsMap::iterator it;
+
+    joints_map_mutex.lock();
+    for( it = joints_map.begin(); it != joints_map.end(); ++it )
+    {
+        it->second.position = math_utils->maut_random(it->second.min, it->second.max);
+    }
+    joints_map_mutex.unlock();
+}
+
+void ParticleSrHand::update(float* sum_weights, boost::mutex* mutex_sum_weights)
+{
+    prediction();
+    compute_probability();
+
+    mutex_sum_weights->lock();
+    *sum_weights += weight;
+    mutex_sum_weights->unlock();
+}
+
+void ParticleSrHand::prediction()
+{
+
+}
+
+void ParticleSrHand::compute_probability()
+{
+    weight = 1.0f;
+}
+
+std::vector<float> ParticleSrHand::get_positions()
+{
+    JointsMap::iterator it;
+    std::vector<float> pos;
+
+    joints_map_mutex.lock();
+    for( it = joints_map.begin(); it != joints_map.end(); ++it )
+    {
+        pos.push_back(it->second.position);
+    }
+    joints_map_mutex.unlock();
+
+    return pos;
+}
+}

=== removed file 'shadow_robot/dataglove/dataglove_processing/src/reverse_kinematics.cpp'
--- shadow_robot/dataglove/dataglove_processing/src/reverse_kinematics.cpp	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/src/reverse_kinematics.cpp	1970-01-01 00:00:00 +0000
@@ -1,62 +0,0 @@
-#include  "optical_dataglove/reverse_kinematics.h"
-
-namespace opticaldataglove{
-
-ReverseKinematics::ReverseKinematics(boost::shared_ptr<DataAnalyser> data_analyser): PositionMapper()
-{
-    this->dataAnalyser=data_analyser;
-    initializeHandPositions();
-}
-
-ReverseKinematics::~ReverseKinematics()
-{
-
-}
-
-std::map<std::string, JointData> ReverseKinematics::getHandPositions()
-{
-    return this->handPositions;
-}
-
-void ReverseKinematics::initializeHandPositions()
-{
-    this->handPositions["THJ1"] = JointData();
-    this->handPositions["THJ1"].position =0.0;
-    this->handPositions["THJ2"] = JointData();
-    this->handPositions["THJ2"].position = 0.0;
-    this->handPositions["THJ3"] = JointData();
-    this->handPositions["THJ3"].position = 0.0;
-    this->handPositions["THJ4"] = JointData();
-    this->handPositions["THJ4"].position = 0.0;
-    this->handPositions["THJ5"] = JointData();
-    this->handPositions["THJ5"].position = 0.0;
-    this->handPositions["FFJ0"] = JointData();
-    this->handPositions["FFJ0"].position = 0.0;
-    this->handPositions["FFJ3"] = JointData();
-    this->handPositions["FFJ3"].position = 0.0;
-    this->handPositions["FFJ4"] = JointData();
-    this->handPositions["FFJ4"].position = 0.0;
-    this->handPositions["MFJ0"] = JointData();
-    this->handPositions["MFJ0"].position = 0.0;
-    this->handPositions["MFJ3"] = JointData();
-    this->handPositions["MFJ3"].position = 0.0;
-    this->handPositions["MFJ4"] = JointData();
-    this->handPositions["MFJ4"].position = 0.0;
-    this->handPositions["RFJ0"] = JointData();
-    this->handPositions["RFJ0"].position = 0.0;
-    this->handPositions["RFJ3"] = JointData();
-    this->handPositions["RFJ3"].position = 0.0;
-    this->handPositions["RFJ4"] = JointData();
-    this->handPositions["RFJ4"].position = 0.0;
-    this->handPositions["LFJ0"] = JointData();
-    this->handPositions["LFJ0"].position = 0.0;
-    this->handPositions["LFJ3"] = JointData();
-    this->handPositions["LFJ3"].position = 0.0;
-    this->handPositions["LFJ4"] = JointData();
-    this->handPositions["LFJ4"].position = 0.0;
-    this->handPositions["LFJ5"] = JointData();
-    this->handPositions["LFJ5"].position = 0.0;
- 
-}
-
-}

=== removed file 'shadow_robot/dataglove/dataglove_processing/src/three_dimensions.cpp'
--- shadow_robot/dataglove/dataglove_processing/src/three_dimensions.cpp	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/src/three_dimensions.cpp	1970-01-01 00:00:00 +0000
@@ -1,31 +0,0 @@
-#include "optical_dataglove/three_dimensions.h"
-
-namespace opticaldataglove{
-
-ThreeDimensionsAnalyser::ThreeDimensionsAnalyser(): DataAnalyser()
-{
-
-}
-
-ThreeDimensionsAnalyser::~ThreeDimensionsAnalyser()
-{
-
-}
-
-std::map<std::string, double> ThreeDimensionsAnalyser::getFingerTipPositions()
-{
-    std::map<std::string, double> ret;
-    return ret;
-}
-
-std::map<std::string, double> ThreeDimensionsAnalyser::getHandModel()
-{
-    std::map<std::string, double> ret;
-    return ret;
-}
-
-
-
-
-
-}

=== removed file 'shadow_robot/dataglove/dataglove_processing/src/two_dimensions.cpp'
--- shadow_robot/dataglove/dataglove_processing/src/two_dimensions.cpp	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/src/two_dimensions.cpp	1970-01-01 00:00:00 +0000
@@ -1,31 +0,0 @@
-#include "optical_dataglove/two_dimensions.h"
-
-namespace opticaldataglove{
-
-TwoDimensionsAnalyser::TwoDimensionsAnalyser(): DataAnalyser()
-{
-
-}
-
-TwoDimensionsAnalyser::~TwoDimensionsAnalyser()
-{
-
-}
-
-std::map<std::string, double> TwoDimensionsAnalyser::getFingerTipPositions()
-{
-    std::map<std::string, double> ret;
-    return ret;
-}
-
-std::map<std::string, double> TwoDimensionsAnalyser::getHandModel()
-{
-    std::map<std::string, double> ret;
-    return ret;
-}
-
-
-
-
-
-}

=== removed directory 'shadow_robot/dataglove/dataglove_processing/srv'
=== removed file 'shadow_robot/dataglove/dataglove_processing/srv/Start.srv'
--- shadow_robot/dataglove/dataglove_processing/srv/Start.srv	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/srv/Start.srv	1970-01-01 00:00:00 +0000
@@ -1,2 +0,0 @@
----
-bool state

=== removed file 'shadow_robot/dataglove/dataglove_processing/srv/Stop.srv'
--- shadow_robot/dataglove/dataglove_processing/srv/Stop.srv	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/srv/Stop.srv	1970-01-01 00:00:00 +0000
@@ -1,2 +0,0 @@
----
-bool state

=== added directory 'shadow_robot/dataglove/dataglove_processing/test'
=== removed directory 'shadow_robot/dataglove/dataglove_processing/test'
=== added file 'shadow_robot/dataglove/dataglove_processing/test/test_dataglove_processing.cpp'
--- shadow_robot/dataglove/dataglove_processing/test/test_dataglove_processing.cpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/dataglove/dataglove_processing/test/test_dataglove_processing.cpp	2010-11-16 14:46:52 +0000
@@ -0,0 +1,211 @@
+/**
+ * @file test_dataglove_processing.cpp
+ * @author Ugo Cupcic <ugo@shadowrobot.com>, Contact <contact@shadowrobot.com>
+ * @date 9 Nov 2010
+ *
+ * @brief Test the Dataglove processing.
+ *
+ *
+ */
+
+#include <ros/ros.h>
+#include <gtest/gtest.h>
+#include "gtest/gtest_prod.h"
+
+#include "dataglove_processing.hpp"
+#include "particle_sr_hand.hpp"
+#include "particle.hpp"
+#include "measure.hpp"
+#include <math_utils.hpp>
+#include <vector>
+#include <algorithm>
+
+#include <boost/smart_ptr.hpp>
+#include <boost/ptr_container/ptr_vector.hpp>
+
+#define TEST_EXPRESSION(a) EXPECT_EQ((a), meval::EvaluateMathExpression(#a))
+
+using namespace dataglove;
+
+namespace dataglove
+{
+class DatagloveProcessingTest : public ::testing::Test
+{
+
+};
+TEST(DatagloveProcessingTest, pfInitWeights)
+{
+    DatagloveProcessing dataglove_processing;
+
+    unsigned int total_nb_particles = dataglove_processing.total_number_of_particles;
+    float average_weight = 1.0f / ((float)total_nb_particles);
+
+    std::vector<float> weights;
+    weights = dataglove_processing.get_weights_vector();
+    EXPECT_TRUE(weights.size() == total_nb_particles)<< "Expected Size = "<< total_nb_particles << " Received size = " << weights.size();
+    std::vector<float>::iterator it;
+    for( it = weights.begin(); it != weights.end(); ++it )
+    {
+        EXPECT_TRUE(*it == average_weight) << "Expected value = " << average_weight << " Received value = " << *it;
+    }
+}
+
+TEST(DatagloveProcessingTest, pfInitPos)
+{
+    DatagloveProcessing dataglove_processing;
+    /*
+     * Test positions are random
+     */
+
+    std::vector<std::vector<float> > all_part_positions;
+    all_part_positions = dataglove_processing.get_particle_positions_vector();
+
+    std::vector<float> first_pos = all_part_positions[0];
+
+    EXPECT_TRUE(first_pos.size() == 28)<< "Wrong number of joints: " << first_pos.size();
+
+    // ignore the first as it's the reference
+    for(unsigned int index=1; index < all_part_positions.size(); ++index)
+    {
+        //compare the 2 vectors
+        bool result = std::equal(first_pos.begin(), first_pos.end(), all_part_positions[index].begin());
+        // they should be different
+        EXPECT_FALSE(result) << "Two position vectors are exactly equal.";
+    }
+}
+
+TEST(DatagloveProcessingTest, sortByWeights)
+{
+    math_utils::MathUtils math_utils;
+    boost::ptr_vector<ParticleSrHand> test_cloud;
+
+    float rand = 0.0f;
+    for( unsigned int i = 0; i < 1000; ++i )
+    {
+        ParticleSrHand* part = new ParticleSrHand(1000);
+        rand = math_utils.maut_random(0.0f, 10.0f);
+        part->set_weight(rand);
+
+        test_cloud.push_back(part);
+    }
+
+    CompareParticleWeights compare_particle_weights;
+    test_cloud.sort(compare_particle_weights);
+
+    boost::ptr_vector<ParticleSrHand>::iterator particle;
+    particle = test_cloud.begin();
+    float current_weight = particle->get_weight();
+    particle++;
+    for( particle; particle != test_cloud.end(); ++particle )
+    {
+        EXPECT_TRUE(particle->get_weight() >= current_weight)<< "Badly sorted: "
+        <<particle->get_weight() <<" < " <<current_weight;
+    }
+
+}
+
+TEST(DatagloveProcessingTest, resampling)
+{
+    DatagloveProcessing dataglove_processing;
+    math_utils::MathUtils math_utils;
+
+    float rand = 0.0f;
+    for( unsigned int i = 0; i < dataglove_processing.total_number_of_particles; ++i )
+    {
+        ParticleSrHand* part = new ParticleSrHand(dataglove_processing.total_number_of_particles);
+        rand = math_utils.maut_random(0.0f, 0.001f);
+        part->set_weight(rand);
+
+        dataglove_processing.particle_cloud->push_back(part);
+    }
+
+    //set n_eff to 0 to have resampling:
+    dataglove_processing.n_eff = 0.0f;
+
+    int different_particles_before_resampling = 0;
+    boost::ptr_vector<ParticleSrHand>::iterator particle = dataglove_processing.particle_cloud->begin();
+    boost::ptr_vector<ParticleSrHand>::iterator old_particle = dataglove_processing.particle_cloud->begin();
+
+    particle ++;
+    for( particle; particle != dataglove_processing.particle_cloud->end(); ++particle )
+    {
+        if(particle == old_particle)
+        {
+            different_particles_before_resampling ++;
+        }
+    }
+
+    int resampled = dataglove_processing.resampling();
+    EXPECT_TRUE(resampled == 1)<< "No resampling";
+    EXPECT_TRUE(dataglove_processing.particle_cloud->size() == dataglove_processing.total_number_of_particles)
+    << "Wrong cloud size after resampling: " << dataglove_processing.particle_cloud->size() << "(expected: "
+    <<dataglove_processing.total_number_of_particles <<" )";
+
+    /*
+     *check if the cloud has really been resampled:
+     */
+    //check if there are enough different particles
+    int different_particles_after_resampling = 0;
+    //TODO: check if there are less different particles than before.
+}
+
+TEST(DatagloveProcessingTest, updateCycle)
+{
+    DatagloveProcessing dataglove_processing;
+    int result = dataglove_processing.update_cycle();
+    EXPECT_TRUE(result == 0 || result == 1) << "Problem encountered while doing the update.";
+
+    boost::ptr_vector<ParticleSrHand>::iterator particle;
+    particle = dataglove_processing.particle_cloud->begin();
+    float recomputed_sum_squared_weights = 0.0f;
+    float recomputed_n_eff = 0.0f;
+    for( particle; particle != dataglove_processing.particle_cloud->end(); ++particle )
+    {
+        recomputed_sum_squared_weights += (particle->get_weight() * particle->get_weight());
+    }
+    recomputed_n_eff = 1.0f / recomputed_sum_squared_weights;
+
+    EXPECT_TRUE(*dataglove_processing.sum_squared_weights == recomputed_sum_squared_weights) << "sum squared weights = "<< *dataglove_processing.sum_squared_weights << " instead of "<<recomputed_sum_squared_weights;
+    EXPECT_TRUE(dataglove_processing.n_eff == recomputed_n_eff) << "N_eff = "<< dataglove_processing.n_eff << " instead of "<<recomputed_n_eff;
+}
+
+bool test_random( float min, float max, int iteration )
+{
+    math_utils::MathUtils math_utils;
+    float result = 0.0f;
+    for( unsigned int i = 0; i < iteration; ++i )
+    {
+        result = math_utils.maut_random(min, max);
+        if( result < min )
+        return false;
+        if( result > max )
+        return false;
+    }
+    return true;
+}
+
+TEST(MathUtils, random)
+{
+    bool is_in_range;
+    is_in_range = test_random(-10.0f, 10.0f, 1000);
+    EXPECT_TRUE(is_in_range)<< "Range -10, 10";
+    is_in_range = test_random(0.0f, 10.0f, 1000);
+    EXPECT_TRUE(is_in_range) << "Range 0, 10";
+    is_in_range = test_random(-10.0f, 0.0f, 1000);
+    EXPECT_TRUE(is_in_range) << "Range -10, 0";
+    is_in_range = test_random(-20.0f, -2.0f, 1000);
+    EXPECT_TRUE(is_in_range) << "Range -20, 2";
+    is_in_range = test_random(2.0f, 20.0f, 1000);
+    EXPECT_TRUE(is_in_range) << "Range 2, 20";
+    is_in_range = test_random(0.4f, 0.4f, 1000);
+    EXPECT_TRUE(is_in_range) << "Range 0.4, 0.4";
+}
+}
+// Run all the tests that were declared with TEST()
+int main( int argc, char **argv )
+{
+    ros::init(argc, argv, "test_dataglove_processing");
+    testing::InitGoogleTest(&argc, argv);
+    return RUN_ALL_TESTS();
+
+}

=== removed file 'shadow_robot/dataglove/dataglove_processing/test/test_usb_cam.launch'
--- shadow_robot/dataglove/dataglove_processing/test/test_usb_cam.launch	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/dataglove/dataglove_processing/test/test_usb_cam.launch	1970-01-01 00:00:00 +0000
@@ -1,13 +0,0 @@
-<launch>
-  <node name="usb_cam" pkg="usb_cam" type="usb_cam_node" output="screen" >
-    <param name="video_device" value="/dev/video0" />
-    <param name="image_width" value="640" />
-    <param name="image_height" value="480" />
-    <param name="pixel_format" value="mjpeg" />
-    <param name="camera_frame_id" value="usb_cam" />
-    <param name="io_method" value="mmap"/>
-  </node>
-  <node name="image_view" pkg="image_view" type="image_view" respawn="false" output="screen">
-    <remap from="image" to="/usb_cam/image_raw"/>
-  </node>
-</launch>
\ No newline at end of file

=== added directory 'shadow_robot/math_utils'
=== added file 'shadow_robot/math_utils/.cproject'
--- shadow_robot/math_utils/.cproject	1970-01-01 00:00:00 +0000
+++ shadow_robot/math_utils/.cproject	2010-11-09 16:42:48 +0000
@@ -0,0 +1,380 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<?fileVersion 4.0.0?>
+
+<cproject>
+	<storageModule moduleId="org.eclipse.cdt.core.settings">
+		<cconfiguration id="org.eclipse.cdt.core.default.config.1">
+			<storageModule buildSystemId="org.eclipse.cdt.core.defaultConfigDataProvider" id="org.eclipse.cdt.core.default.config.1" moduleId="org.eclipse.cdt.core.settings" name="Configuration">
+				<externalSettings/>
+				<extensions>
+					<extension id="org.eclipse.cdt.core.ELF" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.GNU_ELF" point="org.eclipse.cdt.core.BinaryParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.language.mapping">
+				<project-mappings/>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+			<storageModule moduleId="org.eclipse.cdt.make.core.buildtargets">
+				<buildTargets>
+					<target name=": ROSBUILD_genmanifest_eus" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>ROSBUILD_genmanifest_eus</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": ROSBUILD_genmsg_cpp" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>ROSBUILD_genmsg_cpp</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": ROSBUILD_genmsg_eus" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>ROSBUILD_genmsg_eus</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": ROSBUILD_genmsg_java" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>ROSBUILD_genmsg_java</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": ROSBUILD_genmsg_lisp" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>ROSBUILD_genmsg_lisp</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": ROSBUILD_genmsg_oct" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>ROSBUILD_genmsg_oct</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": ROSBUILD_gensrv_cpp" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>ROSBUILD_gensrv_cpp</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": ROSBUILD_gensrv_eus" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>ROSBUILD_gensrv_eus</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": ROSBUILD_gensrv_java" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>ROSBUILD_gensrv_java</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": ROSBUILD_gensrv_lisp" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>ROSBUILD_gensrv_lisp</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": ROSBUILD_gensrv_oct" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>ROSBUILD_gensrv_oct</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": clean-test-results" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>clean-test-results</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": rebuild_cache" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>rebuild_cache</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": rosbuild_precompile" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>rosbuild_precompile</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": rosbuild_premsgsrvgen" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>rosbuild_premsgsrvgen</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": rospack_genmsg" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>rospack_genmsg</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": rospack_genmsg_libexe" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>rospack_genmsg_libexe</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": rospack_gensrv" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>rospack_gensrv</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": test" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>test</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": test-future" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>test-future</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": test-results" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>test-results</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": test-results-run" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>test-results-run</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": tests" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>tests</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": all" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>all</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+					<target name=": clean" path="" targetID="org.eclipse.cdt.make.MakeTargetBuilder">
+						<buildCommand>/usr/bin/make</buildCommand>
+						<buildArguments/>
+						<buildTarget>clean</buildTarget>
+						<stopOnError>true</stopOnError>
+						<useDefaultCommand>false</useDefaultCommand>
+					</target>
+				</buildTargets>
+			</storageModule>
+			<storageModule moduleId="scannerConfiguration">
+				<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId="org.eclipse.cdt.make.core.GCCStandardMakePerProjectProfile"/>
+				<profile id="org.eclipse.cdt.make.core.GCCStandardMakePerProjectProfile">
+					<buildOutputProvider>
+						<openAction enabled="true" filePath=""/>
+						<parser enabled="true"/>
+					</buildOutputProvider>
+					<scannerInfoProvider id="specsFile">
+						<runAction arguments="-E -P -v -dD ${plugin_state_location}/${specs_file}" command="/usr/bin/gcc" useDefault="true"/>
+						<parser enabled="true"/>
+					</scannerInfoProvider>
+				</profile>
+				<profile id="org.eclipse.cdt.make.core.GCCStandardMakePerFileProfile">
+					<buildOutputProvider>
+						<openAction enabled="true" filePath=""/>
+						<parser enabled="true"/>
+					</buildOutputProvider>
+					<scannerInfoProvider id="makefileGenerator">
+						<runAction arguments="-f ${project_name}_scd.mk" command="/usr/bin/make" useDefault="true"/>
+						<parser enabled="true"/>
+					</scannerInfoProvider>
+				</profile>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.internal.ui.text.commentOwnerProjectMappings"/>
+			<storageModule moduleId="org.eclipse.cdt.core.pathentry">
+				<pathentry kind="mac" name="__STDC__" path="" value="1"/>
+				<pathentry kind="mac" name="__STDC_HOSTED__" path="" value="1"/>
+				<pathentry kind="mac" name="__GNUC__" path="" value="4"/>
+				<pathentry kind="mac" name="__GNUC_MINOR__" path="" value="4"/>
+				<pathentry kind="mac" name="__GNUC_PATCHLEVEL__" path="" value="3"/>
+				<pathentry kind="mac" name="__SIZE_TYPE__" path="" value="unsigned"/>
+				<pathentry kind="mac" name="int" path="" value="__PTRDIFF_TYPE__"/>
+				<pathentry kind="mac" name="unsigned" path="" value="int"/>
+				<pathentry kind="mac" name="__INTMAX_TYPE__" path="" value="long"/>
+				<pathentry kind="mac" name="long" path="" value="int"/>
+				<pathentry kind="mac" name="__UINTMAX_TYPE__" path="" value="long"/>
+				<pathentry kind="mac" name="short" path="" value="unsigned"/>
+				<pathentry kind="mac" name="__GXX_ABI_VERSION" path="" value="1002"/>
+				<pathentry kind="mac" name="__SCHAR_MAX__" path="" value="127"/>
+				<pathentry kind="mac" name="__SHRT_MAX__" path="" value="32767"/>
+				<pathentry kind="mac" name="__INT_MAX__" path="" value="2147483647"/>
+				<pathentry kind="mac" name="__LONG_MAX__" path="" value="2147483647L"/>
+				<pathentry kind="mac" name="__LONG_LONG_MAX__" path="" value="9223372036854775807LL"/>
+				<pathentry kind="mac" name="__WCHAR_MAX__" path="" value="2147483647"/>
+				<pathentry kind="mac" name="__CHAR_BIT__" path="" value="8"/>
+				<pathentry kind="mac" name="__INTMAX_MAX__" path="" value="9223372036854775807LL"/>
+				<pathentry kind="mac" name="__FLT_EVAL_METHOD__" path="" value="2"/>
+				<pathentry kind="mac" name="__DEC_EVAL_METHOD__" path="" value="2"/>
+				<pathentry kind="mac" name="__FLT_RADIX__" path="" value="2"/>
+				<pathentry kind="mac" name="__FLT_MANT_DIG__" path="" value="24"/>
+				<pathentry kind="mac" name="__FLT_DIG__" path="" value="6"/>
+				<pathentry kind="mac" name="__FLT_MIN_EXP__" path="" value="(-125)"/>
+				<pathentry kind="mac" name="__FLT_MIN_10_EXP__" path="" value="(-37)"/>
+				<pathentry kind="mac" name="__FLT_MAX_EXP__" path="" value="128"/>
+				<pathentry kind="mac" name="__FLT_MAX_10_EXP__" path="" value="38"/>
+				<pathentry kind="mac" name="__FLT_MAX__" path="" value="3.40282347e+38F"/>
+				<pathentry kind="mac" name="__FLT_MIN__" path="" value="1.17549435e-38F"/>
+				<pathentry kind="mac" name="__FLT_EPSILON__" path="" value="1.19209290e-7F"/>
+				<pathentry kind="mac" name="__FLT_DENORM_MIN__" path="" value="1.40129846e-45F"/>
+				<pathentry kind="mac" name="__FLT_HAS_DENORM__" path="" value="1"/>
+				<pathentry kind="mac" name="__FLT_HAS_INFINITY__" path="" value="1"/>
+				<pathentry kind="mac" name="__FLT_HAS_QUIET_NAN__" path="" value="1"/>
+				<pathentry kind="mac" name="__DBL_MANT_DIG__" path="" value="53"/>
+				<pathentry kind="mac" name="__DBL_DIG__" path="" value="15"/>
+				<pathentry kind="mac" name="__DBL_MIN_EXP__" path="" value="(-1021)"/>
+				<pathentry kind="mac" name="__DBL_MIN_10_EXP__" path="" value="(-307)"/>
+				<pathentry kind="mac" name="__DBL_MAX_EXP__" path="" value="1024"/>
+				<pathentry kind="mac" name="__DBL_MAX_10_EXP__" path="" value="308"/>
+				<pathentry kind="mac" name="__DBL_MAX__" path="" value="1.7976931348623157e+308"/>
+				<pathentry kind="mac" name="__DBL_MIN__" path="" value="2.2250738585072014e-308"/>
+				<pathentry kind="mac" name="__DBL_EPSILON__" path="" value="2.2204460492503131e-16"/>
+				<pathentry kind="mac" name="__DBL_DENORM_MIN__" path="" value="4.9406564584124654e-324"/>
+				<pathentry kind="mac" name="__DBL_HAS_DENORM__" path="" value="1"/>
+				<pathentry kind="mac" name="__DBL_HAS_INFINITY__" path="" value="1"/>
+				<pathentry kind="mac" name="__DBL_HAS_QUIET_NAN__" path="" value="1"/>
+				<pathentry kind="mac" name="__LDBL_MANT_DIG__" path="" value="64"/>
+				<pathentry kind="mac" name="__LDBL_DIG__" path="" value="18"/>
+				<pathentry kind="mac" name="__LDBL_MIN_EXP__" path="" value="(-16381)"/>
+				<pathentry kind="mac" name="__LDBL_MIN_10_EXP__" path="" value="(-4931)"/>
+				<pathentry kind="mac" name="__LDBL_MAX_EXP__" path="" value="16384"/>
+				<pathentry kind="mac" name="__LDBL_MAX_10_EXP__" path="" value="4932"/>
+				<pathentry kind="mac" name="__DECIMAL_DIG__" path="" value="21"/>
+				<pathentry kind="mac" name="__LDBL_MAX__" path="" value="1.18973149535723176502e+4932L"/>
+				<pathentry kind="mac" name="__LDBL_MIN__" path="" value="3.36210314311209350626e-4932L"/>
+				<pathentry kind="mac" name="__LDBL_EPSILON__" path="" value="1.08420217248550443401e-19L"/>
+				<pathentry kind="mac" name="__LDBL_DENORM_MIN__" path="" value="3.64519953188247460253e-4951L"/>
+				<pathentry kind="mac" name="__LDBL_HAS_DENORM__" path="" value="1"/>
+				<pathentry kind="mac" name="__LDBL_HAS_INFINITY__" path="" value="1"/>
+				<pathentry kind="mac" name="__LDBL_HAS_QUIET_NAN__" path="" value="1"/>
+				<pathentry kind="mac" name="__DEC32_MANT_DIG__" path="" value="7"/>
+				<pathentry kind="mac" name="__DEC32_MIN_EXP__" path="" value="(-94)"/>
+				<pathentry kind="mac" name="__DEC32_MAX_EXP__" path="" value="97"/>
+				<pathentry kind="mac" name="__DEC32_MIN__" path="" value="1E-95DF"/>
+				<pathentry kind="mac" name="__DEC32_MAX__" path="" value="9.999999E96DF"/>
+				<pathentry kind="mac" name="__DEC32_EPSILON__" path="" value="1E-6DF"/>
+				<pathentry kind="mac" name="__DEC32_SUBNORMAL_MIN__" path="" value="0.000001E-95DF"/>
+				<pathentry kind="mac" name="__DEC64_MANT_DIG__" path="" value="16"/>
+				<pathentry kind="mac" name="__DEC64_MIN_EXP__" path="" value="(-382)"/>
+				<pathentry kind="mac" name="__DEC64_MAX_EXP__" path="" value="385"/>
+				<pathentry kind="mac" name="__DEC64_MIN__" path="" value="1E-383DD"/>
+				<pathentry kind="mac" name="__DEC64_MAX__" path="" value="9.999999999999999E384DD"/>
+				<pathentry kind="mac" name="__DEC64_EPSILON__" path="" value="1E-15DD"/>
+				<pathentry kind="mac" name="__DEC64_SUBNORMAL_MIN__" path="" value="0.000000000000001E-383DD"/>
+				<pathentry kind="mac" name="__DEC128_MANT_DIG__" path="" value="34"/>
+				<pathentry kind="mac" name="__DEC128_MIN_EXP__" path="" value="(-6142)"/>
+				<pathentry kind="mac" name="__DEC128_MAX_EXP__" path="" value="6145"/>
+				<pathentry kind="mac" name="__DEC128_MIN__" path="" value="1E-6143DL"/>
+				<pathentry kind="mac" name="__DEC128_MAX__" path="" value="9.999999999999999999999999999999999E6144DL"/>
+				<pathentry kind="mac" name="__DEC128_EPSILON__" path="" value="1E-33DL"/>
+				<pathentry kind="mac" name="__DEC128_SUBNORMAL_MIN__" path="" value="0.000000000000000000000000000000001E-6143DL"/>
+				<pathentry kind="mac" name="__REGISTER_PREFIX__" path="" value=""/>
+				<pathentry kind="mac" name="__USER_LABEL_PREFIX__" path="" value=""/>
+				<pathentry kind="mac" name="__VERSION__" path="" value="&quot;4.4.3&quot;"/>
+				<pathentry kind="mac" name="__GNUC_GNU_INLINE__" path="" value="1"/>
+				<pathentry kind="mac" name="__NO_INLINE__" path="" value="1"/>
+				<pathentry kind="mac" name="__FINITE_MATH_ONLY__" path="" value="0"/>
+				<pathentry kind="mac" name="__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1" path="" value="1"/>
+				<pathentry kind="mac" name="__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2" path="" value="1"/>
+				<pathentry kind="mac" name="__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4" path="" value="1"/>
+				<pathentry kind="mac" name="__SSP__" path="" value="1"/>
+				<pathentry kind="mac" name="__SIZEOF_INT__" path="" value="4"/>
+				<pathentry kind="mac" name="__SIZEOF_LONG__" path="" value="4"/>
+				<pathentry kind="mac" name="__SIZEOF_LONG_LONG__" path="" value="8"/>
+				<pathentry kind="mac" name="__SIZEOF_SHORT__" path="" value="2"/>
+				<pathentry kind="mac" name="__SIZEOF_FLOAT__" path="" value="4"/>
+				<pathentry kind="mac" name="__SIZEOF_DOUBLE__" path="" value="8"/>
+				<pathentry kind="mac" name="__SIZEOF_LONG_DOUBLE__" path="" value="12"/>
+				<pathentry kind="mac" name="__SIZEOF_SIZE_T__" path="" value="4"/>
+				<pathentry kind="mac" name="__SIZEOF_WCHAR_T__" path="" value="4"/>
+				<pathentry kind="mac" name="__SIZEOF_WINT_T__" path="" value="4"/>
+				<pathentry kind="mac" name="__SIZEOF_PTRDIFF_T__" path="" value="4"/>
+				<pathentry kind="mac" name="__SIZEOF_POINTER__" path="" value="4"/>
+				<pathentry kind="mac" name="__i386" path="" value="1"/>
+				<pathentry kind="mac" name="__i386__" path="" value="1"/>
+				<pathentry kind="mac" name="i386" path="" value="1"/>
+				<pathentry kind="mac" name="__i486" path="" value="1"/>
+				<pathentry kind="mac" name="__i486__" path="" value="1"/>
+				<pathentry kind="mac" name="__gnu_linux__" path="" value="1"/>
+				<pathentry kind="mac" name="__linux" path="" value="1"/>
+				<pathentry kind="mac" name="__linux__" path="" value="1"/>
+				<pathentry kind="mac" name="linux" path="" value="1"/>
+				<pathentry kind="mac" name="__unix" path="" value="1"/>
+				<pathentry kind="mac" name="__unix__" path="" value="1"/>
+				<pathentry kind="mac" name="unix" path="" value="1"/>
+				<pathentry kind="mac" name="__ELF__" path="" value="1"/>
+				<pathentry kind="mac" name="__DECIMAL_BID_FORMAT__" path="" value="1"/>
+				<pathentry kind="mac" name="__BIGGEST_ALIGNMENT__" path="" value="16"/>
+				<pathentry kind="mac" name="_FORTIFY_SOURCE" path="" value="2"/>
+				<pathentry kind="mac" name="__cplusplus" path="" value="1"/>
+				<pathentry kind="mac" name="__GNUG__" path="" value="4"/>
+				<pathentry kind="mac" name="__GXX_WEAK__" path="" value="1"/>
+				<pathentry kind="mac" name="__DEPRECATED" path="" value="1"/>
+				<pathentry kind="mac" name="__GXX_RTTI" path="" value="1"/>
+				<pathentry kind="mac" name="__EXCEPTIONS" path="" value="1"/>
+				<pathentry kind="mac" name="__GCC_HAVE_DWARF2_CFI_ASM" path="" value="1"/>
+				<pathentry kind="mac" name="_GNU_SOURCE" path="" value="1"/>
+				<pathentry include="/home/ugo/Projects/ROS_interfaces/sr-ros-interface/particlefilter/shadow_robot/math_utils/include" kind="inc" path="" system="true"/>
+				<pathentry include="/home/ugo/ros/ros/core/roscpp/include" kind="inc" path="" system="true"/>
+				<pathentry include="/home/ugo/ros/ros/core/roscpp/msg_gen/cpp/include" kind="inc" path="" system="true"/>
+				<pathentry include="/home/ugo/ros/ros/core/roscpp/srv_gen/cpp/include" kind="inc" path="" system="true"/>
+				<pathentry include="/home/ugo/ros/ros/3rdparty/xmlrpcpp/src" kind="inc" path="" system="true"/>
+				<pathentry include="/home/ugo/ros/ros/core/rosconsole/include" kind="inc" path="" system="true"/>
+				<pathentry include="/home/ugo/ros/ros/core/roslib/include" kind="inc" path="" system="true"/>
+				<pathentry include="/home/ugo/ros/ros/core/roslib/msg_gen/cpp/include" kind="inc" path="" system="true"/>
+				<pathentry include="/home/ugo/ros/ros/tools/rospack" kind="inc" path="" system="true"/>
+				<pathentry include="/home/ugo/ros/ros/tools/rospack/include" kind="inc" path="" system="true"/>
+				<pathentry include="/home/ugo/ros/ros/3rdparty/gtest/gtest/include" kind="inc" path="" system="true"/>
+				<pathentry include="/usr/local/include" kind="inc" path="" system="true"/>
+				<pathentry include="/usr/lib/gcc/i486-linux-gnu/4.4/include" kind="inc" path="" system="true"/>
+				<pathentry include="/usr/lib/gcc/i486-linux-gnu/4.4/include-fixed" kind="inc" path="" system="true"/>
+				<pathentry include="/usr/include/i486-linux-gnu" kind="inc" path="" system="true"/>
+				<pathentry include="/usr/include" kind="inc" path="" system="true"/>
+				<pathentry include="/usr/include/c++/4.4" kind="inc" path="" system="true"/>
+				<pathentry include="/usr/include/c++/4.4/i486-linux-gnu" kind="inc" path="" system="true"/>
+				<pathentry include="/usr/include/c++/4.4/backward" kind="inc" path="" system="true"/>
+				<pathentry excluding="**/CMakeFiles/" kind="out" path=""/>
+				<pathentry kind="src" path=""/>
+			</storageModule>
+		</cconfiguration>
+	</storageModule>
+	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+		<project id="math_utils.null.1" name="math_utils"/>
+	</storageModule>
+</cproject>

=== added file 'shadow_robot/math_utils/.project'
--- shadow_robot/math_utils/.project	1970-01-01 00:00:00 +0000
+++ shadow_robot/math_utils/.project	2010-11-09 16:42:40 +0000
@@ -0,0 +1,110 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>[PART_FILTER]math_utils</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.make.core.makeBuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+				<dictionary>
+					<key>org.eclipse.cdt.core.errorOutputParser</key>
+					<value>org.eclipse.cdt.core.MakeErrorParser;org.eclipse.cdt.core.GCCErrorParser;org.eclipse.cdt.core.GASErrorParser;org.eclipse.cdt.core.GLDErrorParser;</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.append_environment</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.autoBuildTarget</key>
+					<value>all</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.build.arguments</key>
+					<value>test</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.build.command</key>
+					<value>/usr/bin/make</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.build.location</key>
+					<value>/home/ugo/Projects/ROS_interfaces/sr-ros-interface/particlefilter/shadow_robot/math_utils</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.build.target.auto</key>
+					<value>all</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.build.target.clean</key>
+					<value>clean</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.build.target.inc</key>
+					<value>all</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildArguments</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildLocation</key>
+					<value>/home/ugo/Projects/ROS_interfaces/sr-ros-interface/particlefilter/shadow_robot/math_utils</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
+					<value>clean</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.contents</key>
+					<value>org.eclipse.cdt.make.core.activeConfigSettings</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
+					<value>false</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enabledIncrementalBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.environment</key>
+					<value>ROS_ROOT=/home/ugo/ros/ros|PATH=/home/ugo/ros/ros/bin:/home/ugo/ros/ros/bin:/home/ugo/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/ugo/ros_stacks_external/jsk-ros-pkg/openrave_planning/openrave/bin:/home/ugo/ros_stacks_external/jsk-ros-pkg/openrave_planning/openrave/bin|PYTHONPATH=/home/ugo/ros/ros/core/roslib/src:/home/ugo/ros/ros/core/roslib/src::/home/ugo/ros_stacks_external/jsk-ros-pkg/openrave_planning/openrave/share/openrave:/home/ugo/ros_stacks_external/jsk-ros-pkg/openrave_planning/openrave/share/openrave|VERBOSE=1|ROS_PACKAGE_PATH=/home/ugo/ros/stacks/wifi_drivers:/home/ugo/ros/stacks/wg_pr2_apps:/home/ugo/ros/stacks/wg_hardware_test:/home/ugo/ros/stacks/wg_common:/home/ugo/ros/stacks/web_interface:/home/ugo/ros/stacks/vslam:/home/ugo/ros/stacks/visualization_tutorials:/home/ugo/ros/stacks/visualization_common:/home/ugo/ros/stacks/visualization:/home/ugo/ros/stacks/vision_opencv:/home/ugo/ros/stacks/trajectory_filters:/home/ugo/ros/stacks/tabletop_object_perception:/home/ugo/ros/stacks/sql_database:/home/ugo/ros/stacks/sound_drivers:/home/ugo/ros/stacks/slam_karto:/home/ugo/ros/stacks/slam_gmapping:/home/ugo/ros/stacks/simulator_stage:/home/ugo/ros/stacks/simulator_gazebo:/home/ugo/ros/stacks/roslisp_support:/home/ugo/ros/stacks/ros_tutorials:/home/ugo/ros/stacks/ros_realtime:/home/ugo/ros/stacks/robot_model:/home/ugo/ros/stacks/robot_calibration:/home/ugo/ros/stacks/pr2_web_apps:/home/ugo/ros/stacks/pr2_tabletop_manipulation_apps:/home/ugo/ros/stacks/pr2_simulator:/home/ugo/ros/stacks/pr2_self_test:/home/ugo/ros/stacks/pr2_robot:/home/ugo/ros/stacks/pr2_power_drivers:/home/ugo/ros/stacks/pr2_plugs:/home/ugo/ros/stacks/pr2_object_manipulation:/home/ugo/ros/stacks/pr2_navigation_apps:/home/ugo/ros/stacks/pr2_navigation:/home/ugo/ros/stacks/pr2_mechanism:/home/ugo/ros/stacks/pr2_kinematics_with_constraints:/home/ugo/ros/stacks/pr2_kinematics:/home/ugo/ros/stacks/pr2_gui:/home/ugo/ros/stacks/pr2_ethercat_drivers:/home/ugo/ros/stacks/pr2_doors:/home/ugo/ros/stacks/pr2_controllers:/home/ugo/ros/stacks/pr2_common_actions:/home/ugo/ros/stacks/pr2_common:/home/ugo/ros/stacks/pr2_cockpit:/home/ugo/ros/stacks/pr2_calibration:/home/ugo/ros/stacks/pr2_arm_navigation_tests:/home/ugo/ros/stacks/pr2_arm_navigation_apps:/home/ugo/ros/stacks/pr2_arm_navigation:/home/ugo/ros/stacks/pr2_apps:/home/ugo/ros/stacks/point_cloud_perception:/home/ugo/ros/stacks/physics_ode:/home/ugo/ros/stacks/people:/home/ugo/ros/stacks/object_manipulation:/home/ugo/ros/stacks/navigation:/home/ugo/ros/stacks/motion_planning_visualization:/home/ugo/ros/stacks/motion_planning_environment:/home/ugo/ros/stacks/motion_planning_common:/home/ugo/ros/stacks/motion_planners:/home/ugo/ros/stacks/laser_pipeline:/home/ugo/ros/stacks/laser_drivers:/home/ugo/ros/stacks/kinematics:/home/ugo/ros/stacks/joystick_drivers_tutorials:/home/ugo/ros/stacks/joystick_drivers:/home/ugo/ros/stacks/imu_drivers:/home/ugo/ros/stacks/image_transport_plugins:/home/ugo/ros/stacks/image_pipeline:/home/ugo/ros/stacks/image_common:/home/ugo/ros/stacks/graph_mapping:/home/ugo/ros/stacks/geometry_tutorials:/home/ugo/ros/stacks/geometry:/home/ugo/ros/stacks/executive_smach:/home/ugo/ros/stacks/driver_common:/home/ugo/ros/stacks/diagnostics:/home/ugo/ros/stacks/common_tutorials:/home/ugo/ros/stacks/common_msgs:/home/ugo/ros/stacks/common:/home/ugo/ros/stacks/collision_environment:/home/ugo/ros/stacks/camera_drivers:/home/ugo/ros/stacks/arm_navigation:/home/ugo/ros_stacks_external:/home/ugo/Projects/3_FT_DSTL/Software/ros:/home/ugo/Projects/ROS_interfaces/sr-ros-interface/particlefilter/shadow_robot|ROS_MASTER_URI=http://10.1.1.232:11311|</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.fullBuildTarget</key>
+					<value>all</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.stopOnError</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
+					<value>false</value>
+				</dictionary>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.make.core.ScannerConfigBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.make.core.makeNature</nature>
+		<nature>org.eclipse.cdt.make.core.ScannerConfigNature</nature>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+	</natures>
+</projectDescription>

=== added file 'shadow_robot/math_utils/.pydevproject'
--- shadow_robot/math_utils/.pydevproject	1970-01-01 00:00:00 +0000
+++ shadow_robot/math_utils/.pydevproject	2010-11-09 16:29:13 +0000
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<?eclipse-pydev version="1.0"?>
+
+<pydev_project>
+<pydev_property name="org.python.pydev.PYTHON_PROJECT_INTERPRETER">Default</pydev_property>
+<pydev_property name="org.python.pydev.PYTHON_PROJECT_VERSION">python 2.6</pydev_property>
+<pydev_pathproperty name="org.python.pydev.PROJECT_EXTERNAL_SOURCE_PATH">
+<path>/home/ugo/Projects/ROS_interfaces/sr-ros-interface/particlefilter/shadow_robot/math_utils/src</path>
+<path>/home/ugo/ros/ros/core/roscpp/src</path>
+<path>/home/ugo/ros/ros/core/roscpp/lib</path>
+<path>/home/ugo/ros/ros/core/roslib/src</path>
+<path>/home/ugo/ros/ros/core/roslib/lib</path>
+<path>/home/ugo/ros/ros/core/genmsg_cpp/src</path>
+<path>/home/ugo/ros/ros/tools/rospack/lib</path>
+<path>/home/ugo/ros/ros/3rdparty/xmlrpcpp/src</path>
+<path>/home/ugo/ros/ros/3rdparty/xmlrpcpp/lib</path>
+<path>/home/ugo/ros/ros/core/rosconsole/src</path>
+<path>/home/ugo/ros/ros/core/rosconsole/lib</path>
+<path>/home/ugo/ros/ros/core/mk</path>
+<path>/usr/local/lib/python2.6/dist-packages/Yapsy-1.8-py2.6.egg</path>
+<path>/usr/local/lib/python2.6/dist-packages/ETS-3.4.1-py2.6.egg</path>
+<path>/usr/local/lib/python2.6/dist-packages/TraitsGUI-3.4.0-py2.6.egg</path>
+<path>/usr/local/lib/python2.6/dist-packages/TraitsBackendWX-3.4.0-py2.6.egg</path>
+<path>/usr/local/lib/python2.6/dist-packages/TraitsBackendQt-3.4.0-py2.6.egg</path>
+<path>/usr/local/lib/python2.6/dist-packages/Traits-3.4.0-py2.6-linux-i686.egg</path>
+<path>/usr/local/lib/python2.6/dist-packages/SetupDocs-1.0.4-py2.6.egg</path>
+<path>/usr/local/lib/python2.6/dist-packages/SciMath-3.0.5-py2.6-linux-i686.egg</path>
+<path>/usr/local/lib/python2.6/dist-packages/rosinstall-0.5.8-py2.6.egg</path>
+<path>/home/ugo/ros/ros/core/roslib/src</path>
+<path>/home/ugo/Projects/ROS_interfaces/sr-ros-interface/particlefilter/shadow_robot/math_utils</path>
+<path>/home/ugo/ros_stacks_external/jsk-ros-pkg/openrave_planning/openrave/share/openrave</path>
+<path>/usr/lib/python2.6</path>
+<path>/usr/lib/python2.6/plat-linux2</path>
+<path>/usr/lib/python2.6/lib-tk</path>
+<path>/usr/lib/python2.6/lib-dynload</path>
+<path>/usr/lib/python2.6/dist-packages</path>
+<path>/usr/lib/python2.6/dist-packages/PIL</path>
+<path>/usr/lib/python2.6/dist-packages/gst-0.10</path>
+<path>/usr/lib/pymodules/python2.6</path>
+<path>/usr/lib/python2.6/dist-packages/gtk-2.0</path>
+<path>/usr/lib/pymodules/python2.6/gtk-2.0</path>
+<path>/usr/lib/python2.6/dist-packages/wx-2.8-gtk2-unicode</path>
+<path>/usr/local/lib/python2.6/dist-packages</path>
+</pydev_pathproperty>
+</pydev_project>

=== added file 'shadow_robot/math_utils/CMakeLists.txt'
--- shadow_robot/math_utils/CMakeLists.txt	1970-01-01 00:00:00 +0000
+++ shadow_robot/math_utils/CMakeLists.txt	2010-11-09 16:34:25 +0000
@@ -0,0 +1,30 @@
+cmake_minimum_required(VERSION 2.4.6)
+include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)
+
+# Set the build type.  Options are:
+#  Coverage       : w/ debug symbols, w/o optimization, w/ code-coverage
+#  Debug          : w/ debug symbols, w/o optimization
+#  Release        : w/o debug symbols, w/ optimization
+#  RelWithDebInfo : w/ debug symbols, w/ optimization
+#  MinSizeRel     : w/o debug symbols, w/ optimization, stripped binaries
+#set(ROS_BUILD_TYPE RelWithDebInfo)
+
+rosbuild_init()
+
+#set the default path for built executables to the "bin" directory
+set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
+#set the default path for built libraries to the "lib" directory
+set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)
+
+#uncomment if you have defined messages
+#rosbuild_genmsg()
+#uncomment if you have defined services
+#rosbuild_gensrv()
+
+#common commands for building c++ executables and libraries
+rosbuild_add_library(MathUtils src/math_utils.cpp)
+#target_link_libraries(${PROJECT_NAME} another_library)
+#rosbuild_add_boost_directories()
+#rosbuild_link_boost(${PROJECT_NAME} thread)
+#rosbuild_add_executable(example examples/example.cpp)
+#target_link_libraries(example ${PROJECT_NAME})

=== added file 'shadow_robot/math_utils/Makefile'
--- shadow_robot/math_utils/Makefile	1970-01-01 00:00:00 +0000
+++ shadow_robot/math_utils/Makefile	2010-11-09 16:28:59 +0000
@@ -0,0 +1,1 @@
+include $(shell rospack find mk)/cmake.mk
\ No newline at end of file

=== added directory 'shadow_robot/math_utils/bin'
=== added file 'shadow_robot/math_utils/cmake_install.cmake'
--- shadow_robot/math_utils/cmake_install.cmake	1970-01-01 00:00:00 +0000
+++ shadow_robot/math_utils/cmake_install.cmake	2010-11-09 16:29:13 +0000
@@ -0,0 +1,44 @@
+# Install script for directory: /home/ugo/Projects/ROS_interfaces/sr-ros-interface/particlefilter/shadow_robot/math_utils
+
+# Set the install prefix
+IF(NOT DEFINED CMAKE_INSTALL_PREFIX)
+  SET(CMAKE_INSTALL_PREFIX "/usr/local")
+ENDIF(NOT DEFINED CMAKE_INSTALL_PREFIX)
+STRING(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")
+
+# Set the install configuration name.
+IF(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
+  IF(BUILD_TYPE)
+    STRING(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
+           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
+  ELSE(BUILD_TYPE)
+    SET(CMAKE_INSTALL_CONFIG_NAME "RelWithDebInfo")
+  ENDIF(BUILD_TYPE)
+  MESSAGE(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
+ENDIF(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
+
+# Set the component getting installed.
+IF(NOT CMAKE_INSTALL_COMPONENT)
+  IF(COMPONENT)
+    MESSAGE(STATUS "Install component: \"${COMPONENT}\"")
+    SET(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
+  ELSE(COMPONENT)
+    SET(CMAKE_INSTALL_COMPONENT)
+  ENDIF(COMPONENT)
+ENDIF(NOT CMAKE_INSTALL_COMPONENT)
+
+# Install shared libraries without execute permission?
+IF(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)
+  SET(CMAKE_INSTALL_SO_NO_EXE "1")
+ENDIF(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)
+
+IF(CMAKE_INSTALL_COMPONENT)
+  SET(CMAKE_INSTALL_MANIFEST "install_manifest_${CMAKE_INSTALL_COMPONENT}.txt")
+ELSE(CMAKE_INSTALL_COMPONENT)
+  SET(CMAKE_INSTALL_MANIFEST "install_manifest.txt")
+ENDIF(CMAKE_INSTALL_COMPONENT)
+
+FILE(WRITE "/home/ugo/Projects/ROS_interfaces/sr-ros-interface/particlefilter/shadow_robot/math_utils/${CMAKE_INSTALL_MANIFEST}" "")
+FOREACH(file ${CMAKE_INSTALL_MANIFEST_FILES})
+  FILE(APPEND "/home/ugo/Projects/ROS_interfaces/sr-ros-interface/particlefilter/shadow_robot/math_utils/${CMAKE_INSTALL_MANIFEST}" "${file}\n")
+ENDFOREACH(file)

=== added directory 'shadow_robot/math_utils/include'
=== added file 'shadow_robot/math_utils/include/MersenneTwister.h'
--- shadow_robot/math_utils/include/MersenneTwister.h	1970-01-01 00:00:00 +0000
+++ shadow_robot/math_utils/include/MersenneTwister.h	2010-11-10 11:58:03 +0000
@@ -0,0 +1,461 @@
+// MersenneTwister.h
+// Mersenne Twister random number generator -- a C++ class MTRand
+// Based on code by Makoto Matsumoto, Takuji Nishimura, and Shawn Cokus
+// Richard J. Wagner  v1.1  28 September 2009  wagnerr@umich.edu
+
+// The Mersenne Twister is an algorithm for generating random numbers.  It
+// was designed with consideration of the flaws in various other generators.
+// The period, 2^19937-1, and the order of equidistribution, 623 dimensions,
+// are far greater.  The generator is also fast; it avoids multiplication and
+// division, and it benefits from caches and pipelines.  For more information
+// see the inventors' web page at
+// http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
+
+// Reference
+// M. Matsumoto and T. Nishimura, "Mersenne Twister: A 623-Dimensionally
+// Equidistributed Uniform Pseudo-Random Number Generator", ACM Transactions on
+// Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3-30.
+
+// Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
+// Copyright (C) 2000 - 2009, Richard J. Wagner
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 
+//   1. Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//
+//   2. Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//
+//   3. The names of its contributors may not be used to endorse or promote 
+//      products derived from this software without specific prior written 
+//      permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+// The original code included the following notice:
+// 
+//     When you use this, send an email to: m-mat@math.sci.hiroshima-u.ac.jp
+//     with an appropriate reference to your work.
+// 
+// It would be nice to CC: wagnerr@umich.edu and Cokus@math.washington.edu
+// when you write.
+
+#ifndef MERSENNETWISTER_H
+#define MERSENNETWISTER_H
+
+// Not thread safe (unless auto-initialization is avoided and each thread has
+// its own MTRand object)
+
+#include <iostream>
+#include <climits>
+#include <cstdio>
+#include <ctime>
+#include <cmath>
+
+class MTRand {
+// Data
+public:
+	typedef unsigned long uint32;  // unsigned integer type, at least 32 bits
+	
+	enum { N = 624 };       // length of state vector
+	enum { SAVE = N + 1 };  // length of array for save()
+
+protected:
+	enum { M = 397 };  // period parameter
+	
+	uint32 state[N];   // internal state
+	uint32 *pNext;     // next value to get from state
+	int left;          // number of values left before reload needed
+
+// Methods
+public:
+	MTRand( const uint32 oneSeed );  // initialize with a simple uint32
+	MTRand( uint32 *const bigSeed, uint32 const seedLength = N );  // or array
+	MTRand();  // auto-initialize with /dev/urandom or time() and clock()
+	MTRand( const MTRand& o );  // copy
+	
+	// Do NOT use for CRYPTOGRAPHY without securely hashing several returned
+	// values together, otherwise the generator state can be learned after
+	// reading 624 consecutive values.
+	
+	// Access to 32-bit random numbers
+	uint32 randInt();                     // integer in [0,2^32-1]
+	uint32 randInt( const uint32 n );     // integer in [0,n] for n < 2^32
+	double rand();                        // real number in [0,1]
+	double rand( const double n );        // real number in [0,n]
+	double randExc();                     // real number in [0,1)
+	double randExc( const double n );     // real number in [0,n)
+	double randDblExc();                  // real number in (0,1)
+	double randDblExc( const double n );  // real number in (0,n)
+	double operator()();                  // same as rand()
+	
+	// Access to 53-bit random numbers (capacity of IEEE double precision)
+	double rand53();  // real number in [0,1)
+	
+	// Access to nonuniform random number distributions
+	double randNorm( const double mean = 0.0, const double stddev = 1.0 );
+	
+	// Re-seeding functions with same behavior as initializers
+	void seed( const uint32 oneSeed );
+	void seed( uint32 *const bigSeed, const uint32 seedLength = N );
+	void seed();
+	
+	// Saving and loading generator state
+	void save( uint32* saveArray ) const;  // to array of size SAVE
+	void load( uint32 *const loadArray );  // from such array
+	friend std::ostream& operator<<( std::ostream& os, const MTRand& mtrand );
+	friend std::istream& operator>>( std::istream& is, MTRand& mtrand );
+	MTRand& operator=( const MTRand& o );
+
+protected:
+	void initialize( const uint32 oneSeed );
+	void reload();
+	uint32 hiBit( const uint32 u ) const { return u & 0x80000000UL; }
+	uint32 loBit( const uint32 u ) const { return u & 0x00000001UL; }
+	uint32 loBits( const uint32 u ) const { return u & 0x7fffffffUL; }
+	uint32 mixBits( const uint32 u, const uint32 v ) const
+		{ return hiBit(u) | loBits(v); }
+	uint32 magic( const uint32 u ) const
+		{ return loBit(u) ? 0x9908b0dfUL : 0x0UL; }
+	uint32 twist( const uint32 m, const uint32 s0, const uint32 s1 ) const
+		{ return m ^ (mixBits(s0,s1)>>1) ^ magic(s1); }
+	static uint32 hash( time_t t, clock_t c );
+};
+
+// Functions are defined in order of usage to assist inlining
+
+inline MTRand::uint32 MTRand::hash( time_t t, clock_t c )
+{
+	// Get a uint32 from t and c
+	// Better than uint32(x) in case x is floating point in [0,1]
+	// Based on code by Lawrence Kirby (fred@genesis.demon.co.uk)
+	
+	static uint32 differ = 0;  // guarantee time-based seeds will change
+	
+	uint32 h1 = 0;
+	unsigned char *p = (unsigned char *) &t;
+	for( size_t i = 0; i < sizeof(t); ++i )
+	{
+		h1 *= UCHAR_MAX + 2U;
+		h1 += p[i];
+	}
+	uint32 h2 = 0;
+	p = (unsigned char *) &c;
+	for( size_t j = 0; j < sizeof(c); ++j )
+	{
+		h2 *= UCHAR_MAX + 2U;
+		h2 += p[j];
+	}
+	return ( h1 + differ++ ) ^ h2;
+}
+
+inline void MTRand::initialize( const uint32 seed )
+{
+	// Initialize generator state with seed
+	// See Knuth TAOCP Vol 2, 3rd Ed, p.106 for multiplier.
+	// In previous versions, most significant bits (MSBs) of the seed affect
+	// only MSBs of the state array.  Modified 9 Jan 2002 by Makoto Matsumoto.
+	register uint32 *s = state;
+	register uint32 *r = state;
+	register int i = 1;
+	*s++ = seed & 0xffffffffUL;
+	for( ; i < N; ++i )
+	{
+		*s++ = ( 1812433253UL * ( *r ^ (*r >> 30) ) + i ) & 0xffffffffUL;
+		r++;
+	}
+}
+
+inline void MTRand::reload()
+{
+	// Generate N new values in state
+	// Made clearer and faster by Matthew Bellew (matthew.bellew@home.com)
+	static const int MmN = int(M) - int(N);  // in case enums are unsigned
+	register uint32 *p = state;
+	register int i;
+	for( i = N - M; i--; ++p )
+		*p = twist( p[M], p[0], p[1] );
+	for( i = M; --i; ++p )
+		*p = twist( p[MmN], p[0], p[1] );
+	*p = twist( p[MmN], p[0], state[0] );
+	
+	left = N, pNext = state;
+}
+
+inline void MTRand::seed( const uint32 oneSeed )
+{
+	// Seed the generator with a simple uint32
+	initialize(oneSeed);
+	reload();
+}
+
+inline void MTRand::seed( uint32 *const bigSeed, const uint32 seedLength )
+{
+	// Seed the generator with an array of uint32's
+	// There are 2^19937-1 possible initial states.  This function allows
+	// all of those to be accessed by providing at least 19937 bits (with a
+	// default seed length of N = 624 uint32's).  Any bits above the lower 32
+	// in each element are discarded.
+	// Just call seed() if you want to get array from /dev/urandom
+	initialize(19650218UL);
+	register int i = 1;
+	register uint32 j = 0;
+	register int k = ( N > seedLength ? N : seedLength );
+	for( ; k; --k )
+	{
+		state[i] =
+		state[i] ^ ( (state[i-1] ^ (state[i-1] >> 30)) * 1664525UL );
+		state[i] += ( bigSeed[j] & 0xffffffffUL ) + j;
+		state[i] &= 0xffffffffUL;
+		++i;  ++j;
+		if( i >= N ) { state[0] = state[N-1];  i = 1; }
+		if( j >= seedLength ) j = 0;
+	}
+	for( k = N - 1; k; --k )
+	{
+		state[i] =
+		state[i] ^ ( (state[i-1] ^ (state[i-1] >> 30)) * 1566083941UL );
+		state[i] -= i;
+		state[i] &= 0xffffffffUL;
+		++i;
+		if( i >= N ) { state[0] = state[N-1];  i = 1; }
+	}
+	state[0] = 0x80000000UL;  // MSB is 1, assuring non-zero initial array
+	reload();
+}
+
+inline void MTRand::seed()
+{
+	// Seed the generator with an array from /dev/urandom if available
+	// Otherwise use a hash of time() and clock() values
+	
+	// First try getting an array from /dev/urandom
+	FILE* urandom = fopen( "/dev/urandom", "rb" );
+	if( urandom )
+	{
+		uint32 bigSeed[N];
+		register uint32 *s = bigSeed;
+		register int i = N;
+		register bool success = true;
+		while( success && i-- )
+			success = fread( s++, sizeof(uint32), 1, urandom );
+		fclose(urandom);
+		if( success ) { seed( bigSeed, N );  return; }
+	}
+	
+	// Was not successful, so use time() and clock() instead
+	seed( hash( time(NULL), clock() ) );
+}
+
+inline MTRand::MTRand( const uint32 oneSeed )
+	{ seed(oneSeed); }
+
+inline MTRand::MTRand( uint32 *const bigSeed, const uint32 seedLength )
+	{ seed(bigSeed,seedLength); }
+
+inline MTRand::MTRand()
+	{ seed(); }
+
+inline MTRand::MTRand( const MTRand& o )
+{
+	register const uint32 *t = o.state;
+	register uint32 *s = state;
+	register int i = N;
+	for( ; i--; *s++ = *t++ ) {}
+	left = o.left;
+	pNext = &state[N-left];
+}
+
+inline MTRand::uint32 MTRand::randInt()
+{
+	// Pull a 32-bit integer from the generator state
+	// Every other access function simply transforms the numbers extracted here
+	
+	if( left == 0 ) reload();
+	--left;
+	
+	register uint32 s1;
+	s1 = *pNext++;
+	s1 ^= (s1 >> 11);
+	s1 ^= (s1 <<  7) & 0x9d2c5680UL;
+	s1 ^= (s1 << 15) & 0xefc60000UL;
+	return ( s1 ^ (s1 >> 18) );
+}
+
+inline MTRand::uint32 MTRand::randInt( const uint32 n )
+{
+	// Find which bits are used in n
+	// Optimized by Magnus Jonsson (magnus@smartelectronix.com)
+	uint32 used = n;
+	used |= used >> 1;
+	used |= used >> 2;
+	used |= used >> 4;
+	used |= used >> 8;
+	used |= used >> 16;
+	
+	// Draw numbers until one is found in [0,n]
+	uint32 i;
+	do
+		i = randInt() & used;  // toss unused bits to shorten search
+	while( i > n );
+	return i;
+}
+
+inline double MTRand::rand()
+	{ return double(randInt()) * (1.0/4294967295.0); }
+
+inline double MTRand::rand( const double n )
+	{ return rand() * n; }
+
+inline double MTRand::randExc()
+	{ return double(randInt()) * (1.0/4294967296.0); }
+
+inline double MTRand::randExc( const double n )
+	{ return randExc() * n; }
+
+inline double MTRand::randDblExc()
+	{ return ( double(randInt()) + 0.5 ) * (1.0/4294967296.0); }
+
+inline double MTRand::randDblExc( const double n )
+	{ return randDblExc() * n; }
+
+inline double MTRand::rand53()
+{
+	uint32 a = randInt() >> 5, b = randInt() >> 6;
+	return ( a * 67108864.0 + b ) * (1.0/9007199254740992.0);  // by Isaku Wada
+}
+
+inline double MTRand::randNorm( const double mean, const double stddev )
+{
+	// Return a real number from a normal (Gaussian) distribution with given
+	// mean and standard deviation by polar form of Box-Muller transformation
+	double x, y, r;
+	do
+	{
+		x = 2.0 * rand() - 1.0;
+		y = 2.0 * rand() - 1.0;
+		r = x * x + y * y;
+	}
+	while ( r >= 1.0 || r == 0.0 );
+	double s = sqrt( -2.0 * log(r) / r );
+	return mean + x * s * stddev;
+}
+
+inline double MTRand::operator()()
+{
+	return rand();
+}
+
+inline void MTRand::save( uint32* saveArray ) const
+{
+	register const uint32 *s = state;
+	register uint32 *sa = saveArray;
+	register int i = N;
+	for( ; i--; *sa++ = *s++ ) {}
+	*sa = left;
+}
+
+inline void MTRand::load( uint32 *const loadArray )
+{
+	register uint32 *s = state;
+	register uint32 *la = loadArray;
+	register int i = N;
+	for( ; i--; *s++ = *la++ ) {}
+	left = *la;
+	pNext = &state[N-left];
+}
+
+inline std::ostream& operator<<( std::ostream& os, const MTRand& mtrand )
+{
+	register const MTRand::uint32 *s = mtrand.state;
+	register int i = mtrand.N;
+	for( ; i--; os << *s++ << "\t" ) {}
+	return os << mtrand.left;
+}
+
+inline std::istream& operator>>( std::istream& is, MTRand& mtrand )
+{
+	register MTRand::uint32 *s = mtrand.state;
+	register int i = mtrand.N;
+	for( ; i--; is >> *s++ ) {}
+	is >> mtrand.left;
+	mtrand.pNext = &mtrand.state[mtrand.N-mtrand.left];
+	return is;
+}
+
+inline MTRand& MTRand::operator=( const MTRand& o )
+{
+	if( this == &o ) return (*this);
+	register const uint32 *t = o.state;
+	register uint32 *s = state;
+	register int i = N;
+	for( ; i--; *s++ = *t++ ) {}
+	left = o.left;
+	pNext = &state[N-left];
+	return (*this);
+}
+
+#endif  // MERSENNETWISTER_H
+
+// Change log:
+//
+// v0.1 - First release on 15 May 2000
+//      - Based on code by Makoto Matsumoto, Takuji Nishimura, and Shawn Cokus
+//      - Translated from C to C++
+//      - Made completely ANSI compliant
+//      - Designed convenient interface for initialization, seeding, and
+//        obtaining numbers in default or user-defined ranges
+//      - Added automatic seeding from /dev/urandom or time() and clock()
+//      - Provided functions for saving and loading generator state
+//
+// v0.2 - Fixed bug which reloaded generator one step too late
+//
+// v0.3 - Switched to clearer, faster reload() code from Matthew Bellew
+//
+// v0.4 - Removed trailing newline in saved generator format to be consistent
+//        with output format of built-in types
+//
+// v0.5 - Improved portability by replacing static const int's with enum's and
+//        clarifying return values in seed(); suggested by Eric Heimburg
+//      - Removed MAXINT constant; use 0xffffffffUL instead
+//
+// v0.6 - Eliminated seed overflow when uint32 is larger than 32 bits
+//      - Changed integer [0,n] generator to give better uniformity
+//
+// v0.7 - Fixed operator precedence ambiguity in reload()
+//      - Added access for real numbers in (0,1) and (0,n)
+//
+// v0.8 - Included time.h header to properly support time_t and clock_t
+//
+// v1.0 - Revised seeding to match 26 Jan 2002 update of Nishimura and Matsumoto
+//      - Allowed for seeding with arrays of any length
+//      - Added access for real numbers in [0,1) with 53-bit resolution
+//      - Added access for real numbers from normal (Gaussian) distributions
+//      - Increased overall speed by optimizing twist()
+//      - Doubled speed of integer [0,n] generation
+//      - Fixed out-of-range number generation on 64-bit machines
+//      - Improved portability by substituting literal constants for long enum's
+//      - Changed license from GNU LGPL to BSD
+//
+// v1.1 - Corrected parameter label in randNorm from "variance" to "stddev"
+//      - Changed randNorm algorithm from basic to polar form for efficiency
+//      - Updated includes from deprecated <xxxx.h> to standard <cxxxx> forms
+//      - Cleaned declarations and definitions to please Intel compiler
+//      - Revised twist() operator to work on ones'-complement machines
+//      - Fixed reload() function to work when N and M are unsigned
+//      - Added copy constructor and copy operator from Salvador Espana

=== added directory 'shadow_robot/math_utils/include/math_utils'
=== added file 'shadow_robot/math_utils/include/math_utils.hpp'
--- shadow_robot/math_utils/include/math_utils.hpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/math_utils/include/math_utils.hpp	2010-11-10 13:57:36 +0000
@@ -0,0 +1,43 @@
+/**
+ * @file math_utils.hpp
+ * @author Ugo Cupcic <ugo@shadowrobot.com>, Contact <contact@shadowrobot.com>
+ * @date 9 Nov 2010
+ *
+ * @brief 
+ *
+ *
+ */
+
+#ifndef MATH_UTILS_HPP_
+#define MATH_UTILS_HPP_
+
+#include "MersenneTwister.h"
+
+namespace math_utils
+{
+
+class MathUtils
+{
+public:
+    MathUtils(){};
+    ~MathUtils(){};
+
+    /**
+     * Computes a random number between min and max. It is the responsibility
+     * of the user to ensure that min < max as it is not tested.
+     * @param min
+     * @param max
+     * @return random number between min and max
+     */
+    float maut_random(float min, float max);
+
+protected:
+    ///uses the Mersenne Twister algorithm
+    MTRand mtrand;
+};
+
+
+
+}//end namespace
+
+#endif /* MATH_UTILS_HPP_ */

=== added directory 'shadow_robot/math_utils/lib'
=== added file 'shadow_robot/math_utils/mainpage.dox'
--- shadow_robot/math_utils/mainpage.dox	1970-01-01 00:00:00 +0000
+++ shadow_robot/math_utils/mainpage.dox	2010-11-09 16:28:59 +0000
@@ -0,0 +1,26 @@
+/**
+\mainpage
+\htmlinclude manifest.html
+
+\b math_utils is ... 
+
+<!-- 
+Provide an overview of your package.
+-->
+
+
+\section codeapi Code API
+
+<!--
+Provide links to specific auto-generated API documentation within your
+package that is of particular interest to a reader. Doxygen will
+document pretty much every part of your code, so do your best here to
+point the reader to the actual API.
+
+If your codebase is fairly large or has different sets of APIs, you
+should use the doxygen 'group' tag to keep these APIs together. For
+example, the roscpp documentation has 'libros' group.
+-->
+
+
+*/

=== added file 'shadow_robot/math_utils/manifest.xml'
--- shadow_robot/math_utils/manifest.xml	1970-01-01 00:00:00 +0000
+++ shadow_robot/math_utils/manifest.xml	2010-11-09 16:33:37 +0000
@@ -0,0 +1,19 @@
+<package>
+  <description brief="math_utils">
+
+     math_utils
+
+  </description>
+  <author>Ugo Cupcic</author>
+  <license>BSD</license>
+  <review status="unreviewed" notes=""/>
+  <url>http://ros.org/wiki/math_utils</url>
+  <depend package="roscpp"/>
+  <export>
+        <cpp cflags="-I${prefix}/include" lflags="-L${prefix}/lib -lMathUtils"/>
+  </export>
+
+
+</package>
+
+

=== added directory 'shadow_robot/math_utils/src'
=== added directory 'shadow_robot/math_utils/src/euslisp'
=== added file 'shadow_robot/math_utils/src/math_utils.cpp'
--- shadow_robot/math_utils/src/math_utils.cpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/math_utils/src/math_utils.cpp	2010-11-10 13:43:05 +0000
@@ -0,0 +1,26 @@
+/**
+ * @file math_utils.cpp
+ * @author Ugo Cupcic <ugo@shadowrobot.com>, Contact <contact@shadowrobot.com>
+ * @date 9 Nov 2010
+ *
+ * @brief 
+ *
+ *
+ */
+
+#include "math_utils.hpp"
+#include <ros/ros.h>
+namespace math_utils
+{
+
+float MathUtils::maut_random( float min, float max )
+{
+    //TODO: read the seed from entropy key
+    //long int seed = 0;
+    //mtrand.seed(seed);
+    double rand = mtrand.rand();
+    rand *= ((double)(max - min));
+    rand += min;
+    return (float)rand;
+}
+}

=== modified file 'shadow_robot/sr_hand/CMakeLists.txt'
--- shadow_robot/sr_hand/CMakeLists.txt	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/sr_hand/CMakeLists.txt	2010-11-10 09:58:03 +0000
@@ -42,6 +42,14 @@
 rosbuild_add_executable(shadowhand_virtual src/hand/sr_articulated_robot.cpp src/hand/virtual_shadowhand.cpp src/sr_publisher.cpp src/sr_subscriber.cpp src/hand/virtual_shadowhand_node.cpp src/sr_diagnosticer.cpp)
 rosbuild_link_boost(shadowhand_virtual thread)
 
+
+###########################
+#  VIRTUAL HAND  LIBRARY  #
+###########################
+
+rosbuild_add_library(SrVirtual src/hand/sr_articulated_robot.cpp src/hand/virtual_shadowhand_library.cpp)
+rosbuild_link_boost(shadowhand_virtual thread)
+
 ##################
 #    REAL HAND   #
 ##################

=== modified file 'shadow_robot/sr_hand/include/sr_hand/hand/sr_articulated_robot.h'
--- shadow_robot/sr_hand/include/sr_hand/hand/sr_articulated_robot.h	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/sr_hand/include/sr_hand/hand/sr_articulated_robot.h	2010-11-10 11:19:36 +0000
@@ -21,6 +21,7 @@
 
 #include <boost/smart_ptr.hpp>
 #include <boost/thread.hpp>
+#include <boost/noncopyable.hpp>
 
 #ifdef GAZEBO
 #include <sensor_msgs/JointState.h>
@@ -217,7 +218,7 @@
  * One (or more) ROS subscriber and publisher can then share the same instance
  * of a Shadowhand object to update the information contained in this object.
  */
-class SRArticulatedRobot
+class SRArticulatedRobot : boost::noncopyable
 {
 public:
     /**

=== modified file 'shadow_robot/sr_hand/include/sr_hand/hand/virtual_shadowhand.h'
--- shadow_robot/sr_hand/include/sr_hand/hand/virtual_shadowhand.h	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/sr_hand/include/sr_hand/hand/virtual_shadowhand.h	2010-11-09 17:18:44 +0000
@@ -23,6 +23,7 @@
  * programs.
  *
  */
+
 class VirtualShadowhand : public SRArticulatedRobot
 {
 public:

=== added file 'shadow_robot/sr_hand/include/sr_hand/hand/virtual_shadowhand_library.h'
--- shadow_robot/sr_hand/include/sr_hand/hand/virtual_shadowhand_library.h	1970-01-01 00:00:00 +0000
+++ shadow_robot/sr_hand/include/sr_hand/hand/virtual_shadowhand_library.h	2010-11-10 11:44:09 +0000
@@ -0,0 +1,38 @@
+/**
+ * @file virtual_shadowhand_library.h
+ * @author Ugo Cupcic <ugo@shadowrobot.com>, Contact <contact@shadowrobot.com>
+ * @date 10 Nov 2010
+ *
+ * @brief 
+ *
+ *
+ */
+
+#ifndef VIRTUAL_SHADOWHAND_LIBRARY_H_
+#define VIRTUAL_SHADOWHAND_LIBRARY_H_
+
+#include "sr_hand/hand/sr_articulated_robot.h"
+
+namespace shadowrobot
+{
+
+class VirtualShadowhandLibrary : public virtual SRArticulatedRobot
+{
+public:
+    VirtualShadowhandLibrary();
+    ~VirtualShadowhandLibrary(){};
+
+    virtual short sendupdate( std::string joint_name, double target );
+    virtual JointData getJointData( std::string joint_name );
+    virtual JointsMap getAllJointsData();
+
+    virtual short setContrl( std::string contrlr_name, JointControllerData ctrlr_data );
+    virtual JointControllerData getContrl( std::string ctrlr_name );
+
+    virtual short setConfig( std::vector<std::string> myConfig );
+    virtual void getConfig( std::string joint_name );
+    virtual std::vector<DiagnosticData> getDiagnostics();
+};//end class
+
+}//end namespace
+#endif /* VIRTUAL_SHADOWHAND_LIBRARY_H_ */

=== added directory 'shadow_robot/sr_hand/lib'
=== modified file 'shadow_robot/sr_hand/manifest.xml'
--- shadow_robot/sr_hand/manifest.xml	revid:ugo@shadowrobot.com-20101108115530-3j516a3mezz3nifq
+++ shadow_robot/sr_hand/manifest.xml	2010-11-10 16:16:01 +0000
@@ -18,13 +18,12 @@
   <depend package="diagnostic_msgs"/>
   <depend package="kdl_parser"/>
   <depend package="dynamic_reconfigure"/>
-  <depend package="sr_convenient_dependencies"/>
+  <depend package="sr_convenient_dependencies"/> 
   <export>
-	<cpp cflags="-I${prefix}/include"/>
+	<cpp cflags="-I${prefix}/include" lflags="-L${prefix}/lib -lSrVirtual"/>
 	<python path="${prefix}/python_lib"/>
 	<python path="${prefix}/python_lib/grasp"/>
 	<python path="${prefix}/src"/>
-	
   </export>
 </package>
 

=== added file 'shadow_robot/sr_hand/src/hand/virtual_shadowhand_library.cpp'
--- shadow_robot/sr_hand/src/hand/virtual_shadowhand_library.cpp	1970-01-01 00:00:00 +0000
+++ shadow_robot/sr_hand/src/hand/virtual_shadowhand_library.cpp	2010-11-10 13:59:20 +0000
@@ -0,0 +1,134 @@
+/**
+ * @file virtual_shadowhand_library.cpp
+ * @author Ugo Cupcic <ugo@shadowrobot.com>, Contact <contact@shadowrobot.com>
+ * @date 10 Nov 2010
+ *
+ * @brief 
+ *
+ *
+ */
+
+#include "sr_hand/hand/virtual_shadowhand_library.h"
+#include <ros/ros.h>
+#include <map>
+
+namespace shadowrobot
+{
+
+VirtualShadowhandLibrary::VirtualShadowhandLibrary() :
+    SRArticulatedRobot()
+{
+    joints_map_mutex.lock();
+
+     JointData tmpData;
+     JointData tmpDataZero;
+     JointControllerData tmpController;
+     tmpDataZero.isJointZero = 1;
+     tmpDataZero.max = 180.0;
+
+     joints_map["FFJ0"] = tmpDataZero;
+     joints_map["FFJ1"] = tmpData;
+     joints_map["FFJ2"] = tmpData;
+     joints_map["FFJ3"] = tmpData;
+     tmpData.min = -25.0;
+     tmpData.max = 25.0;
+     joints_map["FFJ4"] = tmpData;
+
+     joints_map["MFJ0"] = tmpDataZero;
+     tmpData.min = 0.0;
+     tmpData.max = 90.0;
+     joints_map["MFJ1"] = tmpData;
+     joints_map["MFJ2"] = tmpData;
+     joints_map["MFJ3"] = tmpData;
+     tmpData.min = -25.0;
+     tmpData.max = 25.0;
+     joints_map["MFJ4"] = tmpData;
+
+     joints_map["RFJ0"] = tmpDataZero;
+     tmpData.min = 0.0;
+     tmpData.max = 90.0;
+     joints_map["RFJ1"] = tmpData;
+     joints_map["RFJ2"] = tmpData;
+     joints_map["RFJ3"] = tmpData;
+     tmpData.min = -25.0;
+     tmpData.max = 25.0;
+     joints_map["RFJ4"] = tmpData;
+
+     joints_map["LFJ0"] = tmpDataZero;
+     tmpData.min = 0.0;
+     tmpData.max = 90.0;
+     joints_map["LFJ1"] = tmpData;
+     joints_map["LFJ2"] = tmpData;
+     joints_map["LFJ3"] = tmpData;
+     tmpData.min = -25.0;
+     tmpData.max = 25.0;
+     joints_map["LFJ4"] = tmpData;
+     tmpData.min = 0.0;
+     tmpData.max = 45.0;
+     joints_map["LFJ5"] = tmpData;
+
+     tmpData.min = 0.0;
+     tmpData.max = 90.0;
+     joints_map["THJ1"] = tmpData;
+     tmpData.min = -30.0;
+     tmpData.max = 30.0;
+     joints_map["THJ2"] = tmpData;
+     tmpData.min = -15.0;
+     tmpData.max = 15.0;
+     joints_map["THJ3"] = tmpData;
+     tmpData.min = 0.0;
+     tmpData.max = 75.0;
+     joints_map["THJ4"] = tmpData;
+     tmpData.min = -60.0;
+     tmpData.max = 60.0;
+     joints_map["THJ5"] = tmpData;
+
+     tmpData.min = -30.0;
+     tmpData.max = 40.0;
+     joints_map["WRJ1"] = tmpData;
+     tmpData.min = -30.0;
+     tmpData.max = 10.0;
+     joints_map["WRJ2"] = tmpData;
+
+     joints_map_mutex.unlock();
+}
+
+short VirtualShadowhandLibrary::sendupdate( std::string joint_name, double target )
+{
+    return (short)0;
+}
+
+JointData VirtualShadowhandLibrary::getJointData( std::string joint_name )
+{
+    JointData tmp;
+    return tmp;
+}
+std::map<std::string, JointData> VirtualShadowhandLibrary::getAllJointsData()
+{
+    joints_map_mutex.lock();
+    JointsMap tmp_map = JointsMap(joints_map);
+    joints_map_mutex.unlock();
+    return tmp_map;
+}
+short VirtualShadowhandLibrary::setContrl( std::string contrlr_name, JointControllerData ctrlr_data )
+{
+    return (short)0;
+}
+JointControllerData VirtualShadowhandLibrary::getContrl( std::string ctrlr_name )
+{
+    JointControllerData tmp;
+    return tmp;
+}
+short VirtualShadowhandLibrary::setConfig( std::vector<std::string> myConfig )
+{
+    return (short)0;
+}
+void VirtualShadowhandLibrary::getConfig( std::string joint_name )
+{
+}
+std::vector<DiagnosticData> VirtualShadowhandLibrary::getDiagnostics()
+{
+    std::vector<DiagnosticData> tmp;
+    return tmp;
+}
+}//end namespace

